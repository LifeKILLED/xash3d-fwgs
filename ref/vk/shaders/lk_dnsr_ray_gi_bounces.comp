#version 460 core
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_ray_query: require

#define RAY_QUERY
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "ray_primary_common.glsl"
#include "ray_primary_hit.glsl"
#include "utils.glsl"
#include "noise.glsl"
#include "brdf.h"
#include "lk_dnsr_config.glsl"
#include "lk_dnsr_utils.glsl"

layout(set=0,binding=10,rgba8)   uniform writeonly image2D out_gi_base_color_a;
layout(set=0,binding=11,rgba16f) uniform writeonly image2D out_gi_troughput;
layout(set=0,binding=12,rgba32f) uniform writeonly image2D out_gi_position_t;
layout(set=0,binding=13,rgba16f) uniform writeonly image2D out_gi_normals_gs;
layout(set=0,binding=14,rgba16f) uniform writeonly image2D out_gi_emissive;
layout(set=0,binding=15,rgba32f) uniform writeonly image2D out_gi_prev_bounce_pos;

layout(set=0,binding=16,rgba32f) uniform readonly image2D position_t;
layout(set=0,binding=17,rgba16f) uniform readonly image2D normals_gs;
layout(set=0,binding=18,rgba8)   uniform readonly image2D material_rmxx;
layout(set=0,binding=19,rgba32f) uniform readonly image2D refl_position_t;
layout(set=0,binding=20,rgba16f) uniform readonly image2D refl_normals_gs;
layout(set=0,binding=21,rgba16f) uniform readonly image2D blue_noise;

layout(set = 0, binding = 1) uniform accelerationStructureEXT tlas;

#include "trace_additive.glsl"

#ifndef M_PI
#define M_PI 3.1488
#endif

vec3 randomizedOnHemisphere(vec3 randomVec, vec3 normal) {
	float directionality = dot(normal, randomVec);
	if (directionality > 0.) return normalize(randomVec);
	return -normalize(randomVec);
}

vec3 sampleSphere(vec2 uv)
{
    float y = 2.0 * uv.x - 1;
    float theta = 2.0 * M_PI * uv.y;
    float r = sqrt(1.0 - y * y);
    return vec3(cos(theta) * r, y, sin(theta) * r);
}

// Microfacet bounce from this example https://www.shadertoy.com/view/Md3yWl

vec3 SphereRand( vec2 rand )
{
    rand += vec2(.5);
    float sina = rand.x*2. - 1.;
    float b = 6.283*rand.y;
    float cosa = sqrt(1.-sina*sina);
    return vec3(cosa*cos(b),sina,cosa*sin(b));
}

vec3 PowRand( vec3 rand, vec3 axis, float fpow )
{
	vec3 r = normalize(rand  - vec3(0.5));
	//vec3 r = sampleHemisphere(rand);
    //vec3 r = SphereRand(rand);
    float d = dot(r,axis);
    r -= d*axis;
    r = normalize(r);
    float h = d*.5+.5;
    r *= sqrt( 1. - pow( h, 2./(fpow+1.) ) );
    r += axis*sqrt(1.-dot(r,r));
    return r;
}


bool getHit(vec3 origin, vec3 direction, int mask, inout RayPayloadPrimary payload) {
	rayQueryEXT rq;
	const uint flags = 0
		| gl_RayFlagsCullFrontFacingTrianglesEXT
		//| gl_RayFlagsOpaqueEXT
		//| gl_RayFlagsTerminateOnFirstHitEXT
		//| gl_RayFlagsSkipClosestHitShaderEXT
		;
	const float L = 10000.; // TODO Why 10k?
	rayQueryInitializeEXT(rq, tlas, flags, mask, origin, 0., direction, L);
	while (rayQueryProceedEXT(rq)) {
		if (0 != (rayQueryGetRayFlagsEXT(rq) & gl_RayFlagsOpaqueEXT))
			continue;

		// alpha test
		// TODO check other possible ways of doing alpha test. They might be more efficient
		// (although in this particular primary ray case it's not taht important):
		// 1. Do a separate ray query for alpha masked geometry. Reason: here we might accidentally do the expensive
		//    texture sampling for geometry that's ultimately invisible (i.e. behind walls). Also, shader threads congruence.
		//    Separate pass could be more efficient as it'd be doing the same thing for every invocation.
		// 2. Same as the above, but also with a completely independent TLAS. Why: no need to mask-check geometry for opaque-vs-alpha
		const MiniGeometry geom = readCandidateMiniGeometry(rq);
		const uint tex_base_color = getKusok(geom.kusok_index).tex_base_color;
		const vec4 texture_color = texture(textures[nonuniformEXT(tex_base_color)], geom.uv);

		const float alpha_mask_threshold = .1f;
		if (texture_color.a >= alpha_mask_threshold) {
			rayQueryConfirmIntersectionEXT(rq);
		}
	}

	if (rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionTriangleEXT)
		return false;

	primaryRayHit(rq, payload);
	//L = rayQueryGetIntersectionTEXT(rq, true);
	return true;
}

void main() {
	const ivec2 res = ivec2(imageSize(out_gi_base_color_a));
	const ivec2 pix = ivec2(gl_GlobalInvocationID);
	const ivec2 pix_full = pix * GI_DOWNSAMPLE;

	if (any(greaterThanEqual(pix, res / GI_DOWNSAMPLE)))
		return;

	rand01_state = ubo.ubo.random_seed + pix.x * 1833 +  pix.y * 31337;

//	const ivec3 checker_pix = PixToCheckerboard(pix, res);
//	const ivec2 out_pix = checker_pix.xy;
//	const int checker_transparent = checker_pix.b;

//	const vec4 target    = ubo.ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
//	const vec3 direction = normalize((ubo.ubo.inv_view * vec4(target.xyz, 0)).xyz);
//	const vec3 origin    = (ubo.ubo.inv_view * vec4(0, 0, 0, 1)).xyz + direction * NEAR_PLANE_OFFSET;

	const vec3 forward_position = imageLoad(position_t, pix_full).xyz;
	const vec3 refl_position = imageLoad(refl_position_t, pix_full).xyz;
	const vec3 geometry_normal = normalDecode(imageLoad(normals_gs, pix_full).xy);
	const vec3 refl_geometry_normal = normalDecode(imageLoad(refl_normals_gs, pix_full).xy);
	const float metalness = imageLoad(material_rmxx, pix_full).y;
	
	// metal surfaces have gi pass after 2 bounce (reflection), diffuse surfaces have it after 1 bounce
	vec3 gi_origin = /*metalness > .5 ? refl_position.xyz :*/ forward_position;
	vec3 gi_geometry_normal = /*metalness > .5 ? refl_geometry_normal :*/ geometry_normal;
	vec3 gi_troughput = vec3(1.);

	// fill values by zeroes
	// TODO: move this to bounces cycle
	for (int bounce = 0; bounce < (GI_DOWNSAMPLE * GI_DOWNSAMPLE); bounce++) {
		const ivec2 out_pix = pix + (res / GI_DOWNSAMPLE) * ivec2(bounce / GI_DOWNSAMPLE, bounce % GI_DOWNSAMPLE);
		if (any(greaterThanEqual(out_pix, res)))
			continue;

		imageStore(out_gi_base_color_a, out_pix, vec4(0.));
		imageStore(out_gi_troughput, out_pix, vec4(0.));
		imageStore(out_gi_position_t, out_pix, vec4(0.));
		imageStore(out_gi_prev_bounce_pos, out_pix, vec4(0.));
		imageStore(out_gi_normals_gs, out_pix, vec4(1.)); // save from zero division when normalizing
		imageStore(out_gi_emissive, out_pix, vec4(0.));
	}

	// make bounces
	for (int bounce = 0; bounce < GI_BOUNCES_MAX && bounce < (GI_DOWNSAMPLE * GI_DOWNSAMPLE); bounce++) {
		const ivec2 out_pix = pix + (res / GI_DOWNSAMPLE) * ivec2(bounce / GI_DOWNSAMPLE, bounce % GI_DOWNSAMPLE);
		if (any(greaterThanEqual(out_pix, res)))
			continue;
			
		RayPayloadPrimary payload;
		payload.hit_t = vec4(0.);
		payload.base_color_a = vec4(0.);
		payload.normals_gs = vec4(0.);
		payload.material_rmxx = vec4(0.);
		payload.emissive = vec4(0.);

		//const vec3 sphereRandom = sampleSphere(vec2(rand01(), rand01()));
		const vec3 sphereRandom = sampleSphere(imageLoad(blue_noise, pix).xy);
		const vec3 gi_direction = randomizedOnHemisphere(sphereRandom, gi_geometry_normal);
		bool hitResult = getHit(gi_origin, normalize(gi_direction), GEOMETRY_BIT_OPAQUE, payload);

		if (any(lessThan(gi_troughput, vec3(0.001)))) {
			break;
		}
		else if (hitResult && dot(vec3(1.), payload.emissive.xyz) < 0.001)
		{
			// non emissive, save result and go next bounce
			const vec3 albedo = SRGBtoLINEAR(payload.base_color_a.xyz);
			
			imageStore(out_gi_base_color_a,out_pix, vec4(albedo * gi_troughput, 0.)); // 8 bit value need for lighting pass
			imageStore(out_gi_troughput,   out_pix, vec4(albedo * gi_troughput, 0.));
			imageStore(out_gi_position_t, out_pix, payload.hit_t);
			imageStore(out_gi_prev_bounce_pos, out_pix, vec4(gi_origin, 0.));
			imageStore(out_gi_normals_gs, out_pix, payload.normals_gs);
			
			gi_geometry_normal = normalize(normalDecode(payload.normals_gs.xy));
			gi_origin = payload.hit_t.xyz + gi_geometry_normal * 0.001;
			gi_troughput *= albedo;
		}
		else
		{
			// hit emissive, store it and exit
			imageStore(out_gi_emissive, out_pix, vec4(payload.emissive.xyz * gi_troughput, 0.));
			break;
		}
	}
}
