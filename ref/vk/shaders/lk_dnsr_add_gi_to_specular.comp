#version 460

#include "noise.glsl"
#include "utils.glsl"
#include "color_spaces.glsl"
#include "lk_dnsr_utils.glsl"
#include "lk_dnsr_spherical_harmonics.glsl"

// i don't know why, but gi in reflection looks brighter
#define REFLECTION_MULTIPLIER .33;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D out_specular;

layout(set = 0, binding = 1, rgba8) uniform readonly image2D material_rmxx;
layout(set = 0, binding = 2, rgba8) uniform readonly image2D refl_base_color_a;
layout(set = 0, binding = 3, rgba16f) uniform readonly image2D normals_gs;
layout(set = 0, binding = 4, rgba16f) uniform readonly image2D refl_normals_gs;
layout(set = 0, binding = 5, rgba16f) uniform readonly image2D gi_sh1;
layout(set = 0, binding = 6, rgba16f) uniform readonly image2D gi_sh2;

#define GLSL
#include "ray_interop.h"
#undef GLSL

layout(set = 0, binding = 7) uniform UBO { UniformBuffer ubo; } ubo;


// Blatantly copypasted from https://www.shadertoy.com/view/XsGfWV
vec3 aces_tonemap(vec3 color){
	mat3 m1 = mat3(
		0.59719, 0.07600, 0.02840,
		0.35458, 0.90834, 0.13383,
		0.04823, 0.01566, 0.83777
	);
	mat3 m2 = mat3(
		1.60475, -0.10208, -0.00327,
		-0.53108,  1.10813, -0.07276,
		-0.07367, -0.00605,  1.07602
	);
	vec3 v = m1 * color;
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	//return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));
	return clamp(m2 * (a / b), 0.0, 1.0);
}

vec3 reinhard(vec3 color){
	return color / (color + 1.0);
}

vec3 reinhard02(vec3 c, vec3 Cwhite2) {
	return c * (1. + c / Cwhite2) / (1. + c);
}


void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(normals_gs, uv);
	geometry_normal = normalDecode(n.xy);
	shading_normal = normalDecode(n.zw);
}

void readNormalsRefl(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(refl_normals_gs, uv);
	geometry_normal = normalDecode(n.xy);
	shading_normal = normalDecode(n.zw);
}


void main() {
	ivec2 res = ivec2(imageSize(out_specular));
	ivec2 pix = ivec2(gl_GlobalInvocationID);
	const vec2 uv = (vec2(pix) + .5) / res * 2. - 1.;

	if (any(greaterThanEqual(pix, res))) {
		return;
	}

	const vec3 origin    = (ubo.ubo.inv_view * vec4(0, 0, 0, 1)).xyz;
	const vec4 target    = ubo.ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	const vec3 direction = normalize((ubo.ubo.inv_view * vec4(target.xyz, 0)).xyz);

	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);

	vec3 refl_geometry_normal, refl_shading_normal;
	readNormalsRefl(pix, refl_geometry_normal, refl_shading_normal);

	const vec4 material_rmxx = imageLoad(material_rmxx, pix);
	const float roughness = material_rmxx.r;
	const float metalness = material_rmxx.g;

	// albedo from reflection
	const vec3 refl_base_color = SRGBtoLINEAR(imageLoad(refl_base_color_a, pix).rgb);

	// global illumination re-light
	SH low_freq;
	low_freq.shY = imageLoad(gi_sh1, pix);
	low_freq.CoCg = imageLoad(gi_sh2, pix).xy;

	// global illumination
	const vec3 global_illumination = project_SH_irradiance(low_freq, refl_shading_normal) / STORAGE_SCALE_LF * REFLECTION_MULTIPLIER;
	const vec4 specular = imageLoad(out_specular, pix) + vec4(refl_base_color * global_illumination, 0.);

	imageStore(out_specular, pix, specular);
}
