#version 460

#include "brdf.h"
#include "noise.glsl"
#include "utils.glsl"
#include "color_spaces.glsl"
#include "lk_dnsr_config.glsl"
#include "lk_dnsr_utils.glsl"
#include "lk_dnsr_spherical_harmonics.glsl"


layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform writeonly image2D out_composed;

layout(set = 0, binding = 1, rgba8)   uniform readonly image2D base_color_a;
layout(set = 0, binding = 2, rgba16f) uniform readonly image2D emissive;
layout(set = 0, binding = 3, rgba32f) uniform readonly image2D position_t;
layout(set = 0, binding = 4, rgba16f) uniform readonly image2D normals_gs;
layout(set = 0, binding = 5, rgba8)   uniform readonly image2D material_rmxx;

layout(set = 0, binding = 6, rgba16f) uniform readonly image2D diffuse_denoised;
layout(set = 0, binding = 7, rgba16f) uniform readonly image2D specular_denoised;
layout(set = 0, binding = 8, rgba16f) uniform readonly image2D gi_sh1_denoised;
layout(set = 0, binding = 9, rgba16f) uniform readonly image2D gi_sh2_denoised;
layout(set = 0, binding = 10, rgba32f) uniform readonly image2D refl_position_t;

layout(set = 0, binding = 11, rgba16f) uniform readonly image2D blue_noise;

layout(set = 0, binding = 12, rgba16f) uniform writeonly image2D out_temporal_gi_sh1_denoised;
layout(set = 0, binding = 13, rgba16f) uniform writeonly image2D out_temporal_gi_sh2_denoised;

layout(set = 0, binding = 14, rgba16f) uniform readonly image2D gi_sh1_accum;
layout(set = 0, binding = 15, rgba16f) uniform readonly image2D gi_sh2_accum;

layout(set = 0, binding = 16, rgba32f) uniform readonly image2D gi_position_t;

#define GLSL
#include "ray_interop.h"
#undef GLSL

layout(set = 0, binding = 17) uniform UBO { UniformBuffer ubo; } ubo;

// Blatantly copypasted from https://www.shadertoy.com/view/XsGfWV
vec3 aces_tonemap(vec3 color){
	mat3 m1 = mat3(
		0.59719, 0.07600, 0.02840,
		0.35458, 0.90834, 0.13383,
		0.04823, 0.01566, 0.83777
	);
	mat3 m2 = mat3(
		1.60475, -0.10208, -0.00327,
		-0.53108,  1.10813, -0.07276,
		-0.07367, -0.00605,  1.07602
	);
	vec3 v = m1 * color;
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	//return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));
	return clamp(m2 * (a / b), 0.0, 1.0);
}

vec3 reinhard(vec3 color){
	return color / (color + 1.0);
}

vec3 reinhard02(vec3 c, vec3 Cwhite2) {
	return c * (1. + c / Cwhite2) / (1. + c);
}


void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = FIX_NAN(imageLoad(normals_gs, uv));
	geometry_normal = normalDecode(n.xy);
	shading_normal = normalDecode(n.zw);
}


void main() {
	ivec2 res = ivec2(imageSize(base_color_a));
	ivec2 pix = ivec2(gl_GlobalInvocationID);
	const vec2 uv = (vec2(pix) + .5) / res * 2. - 1.;

	if (any(greaterThanEqual(pix, res))) {
		return;
	}

	const vec3 origin    = (ubo.ubo.inv_view * vec4(0, 0, 0, 1)).xyz;
	const vec4 target    = ubo.ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	const vec3 direction = normalize((ubo.ubo.inv_view * vec4(target.xyz, 0)).xyz);

	//const vec3 colour = FIX_NAN(imageLoad(base_color_a, pix).rgb;

	
	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);


	vec3 colour = vec3(0.);
	vec3 diffuse = vec3(0.);
	vec3 specular = vec3(0.);

	const vec4 material_rmxx = FIX_NAN(imageLoad(material_rmxx, pix));
	const float roughness = material_rmxx.r;
	const float metalness = material_rmxx.g;

	// emissive/sky
	colour += FIX_NAN(imageLoad(emissive, pix)).rgb;

	// albedo
	const vec4 base_color_src = FIX_NAN(imageLoad(base_color_a, pix));
	const vec3 base_color = SRGBtoLINEAR(base_color_src.rgb);

	// gray material diffuse component
	diffuse = FIX_NAN(imageLoad(diffuse_denoised, pix)).rgb;

	// specular from point lights
	specular = FIX_NAN(imageLoad(specular_denoised, pix)).rgb;

	//const vec3 refl_dir = FIX_NAN(imageLoad(refl_position_t, pix).xyz - FIX_NAN(imageLoad(position_t, pix)).xyz;
	const vec3 refl_dir = reflect(normalize(FIX_NAN(imageLoad(position_t, pix)).xyz - origin), shading_normal);

	// global illumination re-light
	SH low_freq;
	low_freq.shY = FIX_NAN(imageLoad(gi_sh1_denoised, pix));
	low_freq.CoCg = FIX_NAN(imageLoad(gi_sh2_denoised, pix)).xy;

	const vec3 diffuse_gi = project_SH_irradiance(low_freq, shading_normal) / STORAGE_SCALE_LF;
	const vec3 reflect_gi = project_SH_irradiance(low_freq, normalize(refl_dir)) / STORAGE_SCALE_LF;

	//specular = mix(specular, reflect_gi, smoothstep(.4,.6, roughness)); // high-roughness reflection so noisy, filter it like GI
	//specular *= 4.; // TODO: ????

	// try to reconstruct pbr-like picture from all components
//	float grayscale = (base_color.r + base_color.g + base_color.b) * 0.33;
//	float specular_level = pow(grayscale, 0.45); // fake specular map

	// global illumination
	//vec3 global_illumination =	vec3(0.);

	// correct roughness by frehnel
	const float NdotS = max(0., dot(normalize(direction.xyz), normalize(-shading_normal)));
	const float fresnel = evalFresnel(vec3(1.), 0., NdotS).x;

	// pbr
	colour += PBRMixFresnel(base_color, diffuse + diffuse_gi * 4.0, specular + reflect_gi * 4.0, metalness, fresnel);


	//colour = diffuse_gi * 10.0;

	// DEBUG: gi accum
//	low_freq.shY = FIX_NAN(imageLoad(gi_sh1_accum, pix));
//	low_freq.CoCg = FIX_NAN(imageLoad(gi_sh2_accum, pix)).xy;
//	colour = project_SH_irradiance(low_freq, shading_normal) / STORAGE_SCALE_LF;

//	colour = normalize(imageLoad(gi_position_t, pix).xyz);

	//colour = FIX_NAN(imageLoad(diffuse_denoised, pix)).rgb;

	//colour *= FIX_NAN(imageLoad(gi_sh2, pix)).w / 1000.;

	//colour = specular;

	//colour = diffuse_gi;

	//colour = diffuse;

	//colour = specular * 0.1 + base_color * 0.02;
	//colour = vec3(1., 0., 0.);

	// HACK: exposure
	// TODO: should be dynamic based on previous frames brightness
#if 0
	if (pix.x >= res.x / 2) {
		colour *= 8.;
	}
#else
	//colour *= .25;
#endif

	//colour = aces_tonemap(colour);
	//colour = reinhard02(colour, vec3(400.));
	//colour = reinhard02(colour, vec3(1.));

#if 0
	if (pix.x < res.x / 2) {
#endif
		//colour *= .25;
		//colour = pow(colour, vec3(1. / 2.2));
		colour = LINEARtoSRGB(colour); // gamma-correction
#if 0
	}
#endif

	// colour *= FIX_NAN(imageLoad(blue_noise, pix)).rgb; // View blue noise for testing

	imageStore(out_composed, pix, vec4(colour, 0.));

	imageStore(out_temporal_gi_sh1_denoised, pix, low_freq.shY);
	imageStore(out_temporal_gi_sh2_denoised, pix, vec4(low_freq.CoCg, 0., 0.));

	//imageStore(dest, pix, FIX_NAN(imageLoad(light_direct_poly, pix)));
}
