#version 460

#include "noise.glsl"
#include "utils.glsl"
#include "lk_dnsr_spherical_harmonics.glsl"
#include "lk_dnsr_utils.glsl"
#include "color_spaces.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;


layout(set = 0, binding = 0, rgba16f) uniform image2D out_specular_accum;
layout(set = 0, binding = 1, rgba16f) uniform image2D out_diffuse_accum;
layout(set = 0, binding = 2, rgba16f) uniform image2D out_gi_sh1_accum;
layout(set = 0, binding = 3, rgba16f) uniform image2D out_gi_sh2_accum;

layout(set = 0, binding = 4, rgba8) uniform readonly image2D base_color_a;

layout(set = 0, binding = 5, rgba16f) uniform readonly image2D light_poly_diffuse;
layout(set = 0, binding = 6, rgba16f) uniform readonly image2D light_poly_specular;

layout(set = 0, binding = 7, rgba16f) uniform readonly image2D light_point_diffuse;
layout(set = 0, binding = 8, rgba16f) uniform readonly image2D light_point_specular;

layout(set = 0, binding = 9, rgba16f) uniform readonly image2D indirect_diffuse;
layout(set = 0, binding = 10, rgba16f) uniform readonly image2D indirect_specular;

layout(set = 0, binding = 11, rgba32f) uniform readonly image2D gi_position_t;
layout(set = 0, binding = 12, rgba32f) uniform readonly image2D position_t;
layout(set = 0, binding = 13, rgba32f) uniform readonly image2D refl_position_t;
layout(set = 0, binding = 14, rgba8) uniform readonly image2D material_rmxx;


void main() {
	ivec2 res = ivec2(imageSize(base_color_a));
	ivec2 pix = ivec2(gl_GlobalInvocationID);

	if (any(greaterThanEqual(pix, res))) {
		return;
	}

	const vec3 diffuse = imageLoad(light_point_diffuse, pix).rgb +
						 imageLoad(light_poly_diffuse, pix).rgb;

	const vec3 reflection = imageLoad(indirect_specular, pix).rgb;

	const vec3 specular =	imageLoad(light_point_specular, pix).rgb +
							imageLoad(light_poly_specular, pix).rgb;


	// global illumination
	vec3 global_illumination =  imageLoad(indirect_diffuse, pix).rgb;

	vec4 gi_sh1 = vec4(0.);
	vec2 gi_sh2 = vec2(0.);

	const vec4 position = imageLoad(position_t, pix);

	// store indirectional light in spherical harmonics
	if (global_illumination.rgb != vec3(0., 0., 0.)) {
		const vec3 indirect_color = global_illumination.rgb * STORAGE_SCALE_LF;
		const vec3 gi_direction_src = imageLoad(gi_position_t, pix).xyz - position.xyz;
		const vec3 gi_direction = length(gi_direction_src) > 0. ? normalize(gi_direction_src) : vec3(1., 0., 0.);

		SH low_freq = irradiance_to_SH(indirect_color, gi_direction);
		gi_sh1 = low_freq.shY;
		gi_sh2 = low_freq.CoCg;
	}

	// store reflection ray length in last free component of gi_sh2
	const vec3 refl_position = imageLoad(refl_position_t, pix).xyz;
	const float reflection_ray_length = length(refl_position - position.xyz);
	
	imageStore(out_specular_accum, pix, vec4(specular, 0.));
	imageStore(out_diffuse_accum, pix, vec4(diffuse, 0.));
	imageStore(out_gi_sh1_accum, pix, gi_sh1);
	imageStore(out_gi_sh2_accum, pix, vec4(gi_sh2, 0., reflection_ray_length));
}
