#version 460

#include "noise.glsl"
#include "utils.glsl"
#include "color_spaces.glsl"
#include "brdf.h"

#define DIFFUSE_REPROJECTION_RESPONSIVITY 0.1
#define SPECULAR_REPROJECTION_RESPONSIVITY 0.1

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct UniformBuffer {
	mat4 inv_proj, inv_view;
	mat4 last_inv_proj, last_inv_view;
	float ray_cone_width;
	uint random_seed;
};

layout(set = 0, binding = 0) uniform UBO { UniformBuffer ubo; };

layout(set = 0, binding = 1, rgba16f) uniform image2D dest;
layout(set = 0, binding = 2, rgba16f) uniform image2D out_reproj_diffuse;
layout(set = 0, binding = 3, rgba16f) uniform image2D out_reproj_specular;

layout(set = 0, binding = 4, rgba8) uniform readonly image2D src_base_color;
layout(set = 0, binding = 5, rgba8) uniform readonly image2D src_material_rmxx;

layout(set = 0, binding = 6, rgba16f) uniform readonly image2D src_light_direct_poly_diffuse;
layout(set = 0, binding = 7, rgba16f) uniform readonly image2D src_light_direct_poly_specular;

layout(set = 0, binding = 8, rgba16f) uniform readonly image2D src_light_direct_point_diffuse;
layout(set = 0, binding = 9, rgba16f) uniform readonly image2D src_light_direct_point_specular;
layout(set = 0, binding = 10, rgba16f) uniform readonly image2D src_emissive;

layout(set = 0, binding = 11, rgba32f) uniform readonly image2D src_position_t;
layout(set = 0, binding = 12, rgba16f) uniform readonly image2D src_normals_gs;
layout(set = 0, binding = 13, rgba16f) uniform readonly image2D src_prev_diffuse;
layout(set = 0, binding = 14, rgba16f) uniform readonly image2D src_prev_specular;
layout(set = 0, binding = 15, rgba32f) uniform readonly image2D src_prev_position_t;

//layout(set = 0, binding = 2, rgba16f) uniform readonly image2D src_light_direct_poly_diffuse;
/* layout(set = 0, binding = 3, rgba16f) uniform readonly image2D src_specular; */
/* layout(set = 0, binding = 4, rgba16f) uniform readonly image2D src_additive; */
/* layout(set = 0, binding = 5, rgba16f) uniform readonly image2D src_normals; */
/* layout(set = 0, binding = 6, rgba32f) uniform readonly image2D src_position_t; */

// Blatantly copypasted from https://www.shadertoy.com/view/XsGfWV
vec3 aces_tonemap(vec3 color){
	mat3 m1 = mat3(
		0.59719, 0.07600, 0.02840,
		0.35458, 0.90834, 0.13383,
		0.04823, 0.01566, 0.83777
	);
	mat3 m2 = mat3(
		1.60475, -0.10208, -0.00327,
		-0.53108,  1.10813, -0.07276,
		-0.07367, -0.00605,  1.07602
	);
	vec3 v = m1 * color;
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	//return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));
	return clamp(m2 * (a / b), 0.0, 1.0);
}

vec3 reinhard(vec3 color){
	return color / (color + 1.0);
}

vec3 reinhard02(vec3 c, vec3 Cwhite2) {
	return c * (1. + c / Cwhite2) / (1. + c);
}

float normpdf2(in float x2, in float sigma) { return 0.39894*exp(-0.5*x2/(sigma*sigma))/sigma; }
float normpdf(in float x, in float sigma) { return normpdf2(x*x, sigma); }

void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_normals_gs, uv);
	geometry_normal = normalDecode(n.xy);
	shading_normal = normalDecode(n.zw);
}

void main() {
	ivec2 res = ivec2(imageSize(src_base_color));
	ivec2 pix = ivec2(gl_GlobalInvocationID);
	const vec2 uv = (pix.xy + .5) / res.xy * 2. - 1.;

	if (any(greaterThanEqual(pix, res))) {
		return;
	}

	/* if (pix.y < res.y / 3) { */
	/* 	imageStore(dest, pix, vec4(pow(float(pix.x) / res.x, 2.2))); return; */
	/* } else if (pix.y < res.y * 2 / 3) { */
	/* 	imageStore(dest, pix, vec4(float(pix.x) / res.x)); return; */
	/* } else { */
	/* 	imageStore(dest, pix, vec4(sqrt(float(pix.x) / res.x))); return; */
	/* } */

	//const float material_index = imageLoad(src_light_direct_poly, pix).a;

	//imageStore(dest, pix, vec4(aces_tonemap(base_color.rgb), 0.)); return;
	//imageStore(dest, pix, vec4((base_color.rgb), 0.)); return;
	//imageStore(dest, pix, vec4(fract(imageLoad(src_position_t, pix).rgb / 10.), 0.)); return;
	//imageStore(dest, pix, vec4((imageLoad(src_light_direct_poly, pix).rgb), 0.)); return;
	//imageStore(dest, pix, vec4((imageLoad(src_light_direct_poly, pix).rgb * base_color.rgb), 0.)); return;
	//imageStore(dest, pix, vec4(imageLoad(src_normals, pix)*.5 + .5f)); return;
	//imageStore(dest, pix, vec4(imageLoad(src_specular, pix)*.5 + .5f)); return;
	//imageStore(dest, pix, vec4(aces_tonemap(imageLoad(src_light_direct_poly, pix).rgb), 0.)); return;
	//imageStore(dest, pix, vec4(aces_tonemap(imageLoad(src_specular, pix).rgb), 0.)); return;

	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);

	//imageStore(dest, pix, vec4(.5 + geometry_normal * .5, 0.)); return;

	/* const uint mi = uint(material_index); */
	/* imageStore(dest, pix, vec4(rand3_f01(uvec3(mi,mi+1,mi+2)), 0.)); */
	/* return; */

	vec3 colour = vec3(0.), diffuse = vec3(0.), speculour = vec3(0.);
	diffuse = imageLoad(src_light_direct_poly_diffuse, pix).rgb +
			  imageLoad(src_light_direct_point_diffuse, pix).rgb;
	speculour = imageLoad(src_light_direct_poly_specular, pix).rgb +
				imageLoad(src_light_direct_point_specular, pix).rgb;


#if 0
	float total_scale = 0.;
	vec3 colour = vec3(0.);
	const int KERNEL_SIZE = 8;
	float specular_total_scale = 0.;
	vec3 speculour = vec3(0.);

	const vec4 center_pos = imageLoad(src_position_t, pix);
	for (int x = -KERNEL_SIZE; x <= KERNEL_SIZE; ++x)
		for (int y = -KERNEL_SIZE; y <= KERNEL_SIZE; ++y) {
			const ivec2 p = pix + ivec2(x, y);
			if (any(greaterThanEqual(p, res)) || any(lessThan(p, ivec2(0)))) {
				continue;
			}

			float scale = 1.f;

			// const vec4 c = imageLoad(src_light_direct_poly, p);
			// if (c.a != material_index)
			// 	continue;

			vec3 sample_geometry_normal, sample_shading_normal;
			readNormals(p, sample_geometry_normal, sample_shading_normal);

			// FIXME also filter by depth, (kusok index?), etc
			//scale *= smoothstep(.9, 1., dot(sample_geometry_normal, geometry_normal));

			const vec4 sample_pos = imageLoad(src_position_t, p);
			scale *= smoothstep(4. * center_pos.w / 100., 0., distance(center_pos.xyz, sample_pos.xyz));

			if ( scale <= 0. )
				continue;

			vec3 diffuse = vec3(0.);
			diffuse += imageLoad(src_light_direct_point_diffuse, p).rgb;
			diffuse += imageLoad(src_light_direct_poly_diffuse, p).rgb;

			vec3 specular = vec3(0.);
			specular += imageLoad(src_light_direct_poly_specular, p).rgb;
			specular += imageLoad(src_light_direct_point_specular, p).rgb;

			{
				const float sigma = KERNEL_SIZE / 2.;
				const float dscale = scale * normpdf(x, sigma) * normpdf(y, sigma);
				colour += dscale * diffuse;
				total_scale += dscale;
			}

			const int SPECULAR_KERNEL_SIZE = 4;
			if (all(lessThan(abs(ivec2(x, y)), ivec2(SPECULAR_KERNEL_SIZE)))) {
				const float spigma = SPECULAR_KERNEL_SIZE / 2.;
				const float specuale = scale * normpdf(x, spigma) * normpdf(y, spigma);
				speculour += specuale * specular;
				specular_total_scale += specuale;
			}
		}

	if (total_scale > 0.) {
		colour /= total_scale;
	}

	if (specular_total_scale > 0.) {
		speculour /= specular_total_scale;
		colour += speculour;
	}
#endif


	// TODO: need to extract reprojecting from this shader because reprojected stuff need svgf denoising pass after this
	const vec3 prev_position = imageLoad(src_position_t, pix).rgb;
	const vec4 clip_space = inverse(ubo.last_inv_proj) * vec4((inverse(ubo.last_inv_view) * vec4(prev_position, 1.)).xyz, 1.);
	const vec2 reproj_uv = clip_space.xy / clip_space.w;
	const ivec2 reproj_pix = ivec2((reproj_uv * 0.5 + vec2(0.5)) * vec2(res));
	const vec3 prev_origin = (ubo.last_inv_view * vec4(0., 0., 0., 1.)).xyz;
	vec3 reprojected_lighting = vec3(0.);
	float diffuse_samples_count = 0.;
	float specular_samples_count = 0.;
	const float reproj_offset_treshold = 0.01 * clip_space.w;
	float better_prev_pos_distance = reproj_offset_treshold;
	vec4 history_diffuse = vec4( diffuse, 0. );
	vec4 history_specular = vec4( speculour, 0. );
	float difference_diffuse = 0.;
	float difference_specular = 0.;
	ivec2 reproj_pix_better = reproj_pix;
	for(int x = -1; x <=1; x++) {
		for(int y = -1; y <=1; y++) {
			const ivec2 p = reproj_pix + ivec2(x, y);
			if (any(greaterThanEqual(p, res)) || any(lessThan(p, ivec2(0)))) {
				continue;
			}
			const vec3 history_position = imageLoad(src_prev_position_t, p).rgb;
			const float current_prev_pos_distance = length(history_position - prev_position);
			if ( current_prev_pos_distance < better_prev_pos_distance ) {
				better_prev_pos_distance = current_prev_pos_distance;
				history_diffuse = imageLoad(src_prev_diffuse, p );
				history_specular = imageLoad(src_prev_specular, p );
				reproj_pix_better = p;
			}
		}
	}
	if (better_prev_pos_distance < reproj_offset_treshold) {
		float curr_weight = 0.;
		float reproj_weight = 0.;
		float curr_diffuse_luminance = 0.;
		float curr_specular_luminance = 0.;
		float reproj_diffuse_luminance = 0.;
		float reproj_specular_luminance = 0.;
		const int difference_kernel = 2;
		for(int x = -difference_kernel; x <=difference_kernel; x++) {
			for(int y = -difference_kernel; y <=difference_kernel; y++) {
				const ivec2 curr_p = pix + ivec2(x, y);
				const ivec2 reproj_p = reproj_pix + ivec2(x, y);
				if (any(greaterThanEqual(curr_p, ivec2(0))) || any(lessThan(curr_p, res))) {
					curr_diffuse_luminance += luminance( imageLoad(src_light_direct_point_diffuse, curr_p).rgb +
														imageLoad(src_light_direct_poly_diffuse, curr_p).rgb );
					curr_specular_luminance += luminance( imageLoad(src_light_direct_point_specular, curr_p).rgb +
														 imageLoad(src_light_direct_poly_specular, curr_p).rgb );
					curr_weight += 1.;
				}
				if (any(greaterThanEqual(reproj_p, ivec2(0))) || any(lessThan(reproj_p, res))) {
					reproj_diffuse_luminance += luminance( imageLoad(src_prev_diffuse, reproj_p ).rgb );
					reproj_specular_luminance += luminance( imageLoad(src_prev_specular, reproj_p ).rgb );
					reproj_weight += 1.;
				}
			}
		}
		curr_diffuse_luminance /= curr_weight;
		curr_specular_luminance /= curr_weight;
		reproj_diffuse_luminance /= reproj_weight;
		reproj_specular_luminance /= reproj_weight;
		difference_diffuse = abs(curr_diffuse_luminance - reproj_diffuse_luminance) / (curr_diffuse_luminance + 0.0001);
		difference_specular = abs(curr_specular_luminance - reproj_specular_luminance) / (curr_specular_luminance + 0.0001);
	}
	diffuse_samples_count = history_diffuse.w + 1.;
	specular_samples_count = history_specular.w + 1.;
	const float diffuse_weight = clamp(1. - 1. / diffuse_samples_count, .0, .98);
	const float specular_weight = clamp(1. - 1. / diffuse_samples_count, .0, .98);
	const vec3 mixed_diffuse = mix(diffuse, history_diffuse.rgb, diffuse_weight);
	const vec3 mixed_specular = mix(speculour, history_specular.rgb, specular_weight);
	diffuse = mix(mixed_diffuse, diffuse, min( 1., difference_diffuse * DIFFUSE_REPROJECTION_RESPONSIVITY ) );
	speculour = mix(mixed_specular, speculour, min( 1., difference_specular * SPECULAR_REPROJECTION_RESPONSIVITY ) );
	diffuse_samples_count = mix(diffuse_samples_count, 0.01, min( 1., difference_diffuse * DIFFUSE_REPROJECTION_RESPONSIVITY ) );
	specular_samples_count = mix(specular_samples_count, 0.01, min( 1., difference_specular * SPECULAR_REPROJECTION_RESPONSIVITY) );

	// pbr mix
	const vec4 target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	const vec3 direction = normalize((ubo.inv_view * vec4(target.xyz, 0)).xyz);
	const vec4 base_color = SRGBtoLINEAR(imageLoad(src_base_color, pix));
	const vec4 material_data = imageLoad(src_material_rmxx, pix);
	const float metalness = material_data.y;
	const float NdotS = max(0., dot(normalize(direction.xyz), normalize(-shading_normal)));
	const float fresnel = evalFresnel(vec3(1.), 0., NdotS).x;
	const vec3 metal_colour = speculour * base_color.rgb;
	const float diffuse_specular_factor = mix(0.04, 0.04, fresnel);
	const vec3 dielectric_colour = mix(diffuse * base_color.rgb, speculour, diffuse_specular_factor);
	colour = mix(dielectric_colour, metal_colour, metalness);

	colour += imageLoad(src_emissive, pix).rgb;
	//colour += imageLoad(src_additive, pix).rgb;


	// HACK: exposure
	// TODO: should be dynamic based on previous frames brightness
#if 0
	if (pix.x >= res.x / 2) {
		colour *= 8.;
	}
#else
	//colour *= .25;
#endif

	//colour = aces_tonemap(colour);
	//colour = reinhard02(colour, vec3(400.));
	//colour = reinhard02(colour, vec3(1.));

#if 0
	if (pix.x < res.x / 2) {
#endif
		//colour *= .25;
		colour = LINEARtoSRGB(colour); // gamma-correction
#if 0
	}
#endif

	imageStore(dest, pix, vec4(colour, 0.));
	imageStore(out_reproj_diffuse, pix, vec4(diffuse, diffuse_samples_count));
	imageStore(out_reproj_specular, pix, vec4(speculour, specular_samples_count));
	//imageStore(dest, pix, imageLoad(src_light_direct_poly, pix));
}
