#version 460 core
#extension GL_GOOGLE_include_directive : require

#include "ray_primary_common.glsl"
#include "utils.glsl"
#include "noise.glsl"
#include "color_spaces.glsl"

#define X(index, name, format) layout(set=0,binding=index,format) uniform readonly image2D src_image_##name;
RAY_INDIRECTIONAL_INPUTS(X)
#undef X

#define X(index, name, format) layout(set=0,binding=index,format) uniform image2D out_image_##name;
RAY_INDIRECTIONAL_OUTPUTS(X)
#undef X

layout(set = 0, binding = 1) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 2) uniform UBO { UniformBuffer ubo; };

layout(location = PAYLOAD_LOCATION_PRIMARY) rayPayloadEXT RayPayloadPrimary payload;

void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_image_normals_gs, uv);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}

float ggxNormalDistribution( float NdotH, float roughness )
{
#ifndef M_PI
#define M_PI 3.1488
#endif
	float a2 = roughness * roughness;
	float d = ((NdotH * a2 - NdotH) * NdotH + 1);
	return a2 / (d * d * M_PI);
}

vec3 randomizedOnHemisphere(vec3 randomVec, vec3 normal) {
	float directionality = normalize(dot(normal, randomVec));
	return normalize(directionality * randomVec);
}

void main() {
	const vec2 uv = (gl_LaunchIDEXT.xy + .5) / gl_LaunchSizeEXT.xy * 2. - 1.;
	const ivec2 pix = ivec2(gl_LaunchIDEXT.xy);
	rand01_state = ubo.random_seed + gl_LaunchIDEXT.x * 1833 +  gl_LaunchIDEXT.y * 31337;

	// FIXME start on a near plane
	const vec3 view_origin    = (ubo.inv_view * vec4(0, 0, 0, 1)).xyz;
	const vec4 view_target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	const vec3 view_dir = normalize((ubo.inv_view * vec4(view_target.xyz, 0)).xyz);

	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);

	const vec3 origin = imageLoad(src_image_position_t, pix).xyz + geometry_normal * 0.01;

	const vec4 material_data = imageLoad(src_image_material_rmxx, pix);

	const vec3 randomVec = vec3(rand01(), rand01(), rand01()) * 2.0 - vec3(1.0);

	const vec3 u = controlledRandomDirection(pix, randomVec);

	vec3 direction = randomizedOnHemisphere(u, geometry_normal);

	payload.hit_t = vec4(0.);
	payload.base_color_a = vec4(0.);
	payload.normals_gs = vec4(0.);
	payload.material_rmxx = vec4(0.);
	payload.emissive = vec4(0.);

	const uint flags = gl_RayFlagsCullFrontFacingTrianglesEXT;
	const uint sbt_offset = 0;
	const uint sbt_stride = 0;
	const float L = 10000.; // TODO Why 10k?
	traceRayEXT(tlas, flags, GEOMETRY_BIT_OPAQUE, // | GEOMETRY_BIT_REFRACTIVE,
		sbt_offset, sbt_stride, SHADER_OFFSET_MISS_REGULAR,
		origin, 0., normalize(direction), L,
		PAYLOAD_LOCATION_PRIMARY);

	vec3 gi_direction = normalize(payload.hit_t.xyz - origin);

	imageStore(out_image_gi_position_t, ivec2(gl_LaunchIDEXT.xy), payload.hit_t);
	imageStore(out_image_gi_base_color_a, ivec2(gl_LaunchIDEXT.xy), payload.base_color_a);
	imageStore(out_image_gi_normals_gs, ivec2(gl_LaunchIDEXT.xy), payload.normals_gs);
	imageStore(out_image_gi_material_rmxx, ivec2(gl_LaunchIDEXT.xy), payload.material_rmxx);
	imageStore(out_image_gi_emissive, ivec2(gl_LaunchIDEXT.xy), payload.emissive);
	imageStore(out_image_gi_direction, ivec2(gl_LaunchIDEXT.xy), vec4(gi_direction, material_data.g));
}
