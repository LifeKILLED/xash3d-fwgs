#version 460 core
#extension GL_GOOGLE_include_directive : require

// Reflection of emissive surfaces make a lot of hight light noise
// This trick make specular highlights a less noisy
//#define EXTRA_SAMPLES_FOR_EMISSIVE_REFLECTION 3

#include "ray_primary_common.glsl"
#include "color_spaces.glsl"
#include "utils.glsl"
#include "noise.glsl"
#include "denoiser_tools.glsl"
#include "brdf.h"

#define X(index, name, format) layout(set=0,binding=index,format) uniform image2D out_image_##name;
RAY_PRIMARY_OUTPUTS(X)
#undef X

layout(set = 0, binding = 1) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 2) uniform UBO { UniformBuffer ubo; };

// TODO: only for one texture, but... too many dependencies if we want to add special descriptor
layout(set = 0, binding = 6) uniform sampler2D textures[MAX_TEXTURES];

layout(location = PAYLOAD_LOCATION_PRIMARY) rayPayloadEXT RayPayloadPrimary payload;


float ggxNormalDistribution( float NdotH, float roughness )
{
#ifndef M_PI
#define M_PI 3.1488
#endif
	float a2 = roughness * roughness;
	float d = ((NdotH * a2 - NdotH) * NdotH + 1);
	return a2 / (d * d * M_PI);
}


vec3 randomizedOnHemisphere(vec3 randomVec, vec3 normal) {
	float directionality = normalize(dot(normal, randomVec));
	return normalize(directionality * randomVec);
}

vec3 simpleRoughnessReflection(vec3 randomVec, vec3 viewDir, vec3 normal, float roughness) {
	vec3 clear = reflect(viewDir, normal);
	vec3 randomized = randomizedOnHemisphere(randomVec, normal);
	float distribution = ggxNormalDistribution(dot(normal, viewDir), roughness);
	return normalize(mix(clear, randomized, distribution * 0.5));
}


float maximalDotProduct(float roughness) {
	const vec3 normal = vec3(0., 0., 1.);
	const vec3 maxOffset = vec3(1., 0., 0.);
	const vec3 viewDir = vec3(0., 0., -1.);
	float distribution = ggxNormalDistribution(dot(normal, viewDir), roughness);
	vec3 normalOffset = normalize(mix(normal, viewDir, distribution * 0.5));
	return dot(normal, maxOffset);
}

vec3 sampleSphere(vec2 uv)
{
    float y = 2.0 * uv.x - 1;
    float theta = 2.0 * M_PI * uv.y;
    float r = sqrt(1.0 - y * y);
    return vec3(cos(theta) * r, y, sin(theta) * r);
}

// Microfacet bounce from this example https://www.shadertoy.com/view/Md3yWl

vec3 SphereRand( vec2 rand )
{
    rand += .5;
    float sina = rand.x*2. - 1.;
    float b = 6.283*rand.y;
    float cosa = sqrt(1.-sina*sina);
    return vec3(cosa*cos(b),sina,cosa*sin(b));
}

vec3 PowRand( vec3 rand, vec3 axis, float fpow )
{
	vec3 r = normalize(rand  - vec3(0.5));
	//vec3 r = sampleHemisphere(rand);
    //vec3 r = SphereRand(rand);
    float d = dot(r,axis);
    r -= d*axis;
    r = normalize(r);
    float h = d*.5+.5;
    r *= sqrt( 1. - pow( h, 2./(fpow+1.) ) );
    r += axis*sqrt(1.-dot(r,r));
    return r;
}

// http://jcgt.org/published/0007/04/01/paper.pdf by Eric Heitz
// Input Ve: view direction
// Input alpha_x, alpha_y: roughness parameters
// Input U1, U2: uniform random numbers
// Output Ne: normal sampled with PDF D_Ve(Ne) = G1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z
vec3 SampleGGXVNDF(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2) {
    // Section 3.2: transforming the view direction to the hemisphere configuration
    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));
    // Section 4.1: orthonormal basis (with special case if cross product is zero)
    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
    vec3 T1 = lensq > 0 ? vec3(-Vh.y, Vh.x, 0) * rsqrt(lensq) : vec3(1, 0, 0);
    vec3 T2 = cross(Vh, T1);
    // Section 4.2: parameterization of the projected area
    float r = sqrt(U1);
    float phi = 2.0 * M_PI * U2;
    float t1 = r * cos(phi);
    float t2 = r * sin(phi);
    float s = 0.5 * (1.0 + Vh.z);
    t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;
    // Section 4.3: reprojection onto hemisphere
    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;
    // Section 3.4: transforming the normal back to the ellipsoid configuration
    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0, Nh.z)));
    return Ne;
}

vec3 Sample_GGX_VNDF_Ellipsoid(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2) {
    return SampleGGXVNDF(Ve, alpha_x, alpha_y, U1, U2);
}

vec3 Sample_GGX_VNDF_Hemisphere(vec3 Ve, float alpha, float U1, float U2) {
    return Sample_GGX_VNDF_Ellipsoid(Ve, alpha, alpha, U1, U2);
}

mat3 CreateTBN(vec3 N) {
    vec3 U;
    if (abs(N.z) > 0.0) {
        float k = sqrt(N.y * N.y + N.z * N.z);
        U.x = 0.0; U.y = -N.z / k; U.z = N.y / k;
    }
    else {
        float k = sqrt(N.x * N.x + N.y * N.y);
        U.x = N.y / k; U.y = -N.x / k; U.z = 0.0;
    }

    mat3 TBN;
    TBN[0] = U;
    TBN[1] = cross(N, U);
    TBN[2] = N;
    return transpose(TBN);
}

vec3 SampleReflectionVector(vec3 view_direction, vec3 normal, float roughness, vec2 u) {
    mat3 tbn_transform = CreateTBN(normal);
    vec3 view_direction_tbn = (-view_direction) * tbn_transform;
    
    vec3 sampled_normal_tbn = Sample_GGX_VNDF_Hemisphere(view_direction_tbn, roughness, u.x, u.y);
    #ifdef PERFECT_REFLECTIONS
        sampled_normal_tbn = vec3(0, 0, 1); // Overwrite normal sample to produce perfect reflection.
    #endif
    
    vec3 reflected_direction_tbn = reflect(-view_direction_tbn, sampled_normal_tbn);

    // Transform reflected_direction back to the initial space.
    mat3 inv_tbn_transform = transpose(tbn_transform);
    return reflected_direction_tbn * inv_tbn_transform;
}

void main() {
	const vec2 uv = (gl_LaunchIDEXT.xy + .5) / gl_LaunchSizeEXT.xy * 2. - 1.;
	const ivec2 pix = ivec2(gl_LaunchIDEXT.xy);
	rand01_state = ubo.random_seed + gl_LaunchIDEXT.x * 1833 +  gl_LaunchIDEXT.y * 31337;

	// FIXME start on a near plane
	const vec3 origin    = (ubo.inv_view * vec4(0, 0, 0, 1)).xyz;
	const vec4 target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	const vec3 direction = normalize((ubo.inv_view * vec4(target.xyz, 0)).xyz);

		// ----------- //
		// FROM CAMERA //
		// ----------- //

	payload.hit_t = vec4(0.);
	payload.base_color_a = vec4(0.);
	payload.normals_gs = vec4(0.);
	payload.material_rmxx = vec4(0.);
	payload.emissive = vec4(0.);

	const uint flags = gl_RayFlagsCullFrontFacingTrianglesEXT;
	const uint sbt_offset = 0;
	const uint sbt_stride = 0;
	const float L = 10000.; // TODO Why 10k?
	traceRayEXT(tlas, flags, GEOMETRY_BIT_OPAQUE, // | GEOMETRY_BIT_REFRACTIVE,
		sbt_offset, sbt_stride, SHADER_OFFSET_MISS_REGULAR,
		origin, 0., direction, L,
		PAYLOAD_LOCATION_PRIMARY);

	float depth = length(origin - payload.hit_t.xyz);


	const vec4 out_position_t = vec4(payload.hit_t.xyz, depth);
	const vec4 out_base_color_a = payload.base_color_a;
	const vec4 out_normals_gs = payload.normals_gs;
	const vec4 out_material_rmxx = payload.material_rmxx;
	const vec4 out_emissive = payload.emissive;
	const vec4 out_search_info_ktuv = payload.search_info_ktuv;

		// ---------------------------- //
		// REFLECTION / SPECULAR BOUNCE //
		// ---------------------------- //


		
	const vec3 geometry_normal = normalize(normalDecode(out_normals_gs.xy));
	const vec3 shading_normal = normalize(normalDecode(out_normals_gs.zw));

	const vec3 bounce_origin = out_position_t.xyz + geometry_normal * 0.001;

	const float roughness = out_material_rmxx.r;
	vec3 refl_emissive = vec3(0.);

	// sample blue noise
	// vec2 blue_noise_uv = vec2(pix % ivec2(BLUE_NOISE_TEX_RESOLUTION)) / vec2(BLUE_NOISE_TEX_RESOLUTION);
	// vec4 blue_noise = texture(textures[nonuniformEXT(ubo.blue_noise_seed + BLUE_NOISE_TEX_ID)], blue_noise_uv);
	//const vec3 noise_vec = blue_noise.xyz;

	//const float specPower = 1./ pow(material.roughness, 4.5);

#ifdef EXTRA_SAMPLES_FOR_EMISSIVE_REFLECTION
	for (int n = 0; n < EXTRA_SAMPLES_FOR_EMISSIVE_REFLECTION; n++) {	
#endif

		const vec3 noise_vec = vec3(rand01(),rand01(),rand01());
		//const vec3 microfacet = PowRand( noise_vec, shading_normal, specPower );
		//vec3 direction = reflect(view_dir, microfacet);
		//float coplanar = dot(geometry_normal, direction);
		//if (coplanar < 0.) {
		//	direction += geometry_normal * (coplanar * -2.);
		//}

		const vec3 refl_direction = SampleReflectionVector(direction, shading_normal, roughness, noise_vec.xy);

		payload.hit_t = vec4(0.);
		payload.base_color_a = vec4(0.);
		payload.normals_gs = vec4(0.);
		payload.material_rmxx = vec4(0.);
		payload.emissive = vec4(0.);

		traceRayEXT(tlas, flags, GEOMETRY_BIT_OPAQUE, // | GEOMETRY_BIT_REFRACTIVE,
			sbt_offset, sbt_stride, SHADER_OFFSET_MISS_REGULAR,
			bounce_origin, 0., normalize(refl_direction), L,
			PAYLOAD_LOCATION_PRIMARY);

		refl_emissive += max(vec3(0.), payload.emissive.rgb);

#ifdef EXTRA_SAMPLES_FOR_EMISSIVE_REFLECTION
	}

	refl_emissive /= EXTRA_SAMPLES_FOR_EMISSIVE_REFLECTION;
#endif

	const vec4 out_refl_position_t = vec4(payload.hit_t.xyz, roughness);
	const vec4 out_refl_base_color_a = vec4(payload.base_color_a.rgb, payload.material_rmxx.y);
	const vec4 out_refl_normals_gs = payload.normals_gs;
	const vec4 out_refl_material_rmxx = payload.material_rmxx;
	const vec4 out_refl_emissive = vec4(refl_emissive, 0.);


		// -------------------------------- //
		// FIRST GLOBAL ILLUMINATION BOUNCE //
		// -------------------------------- //
	
	const vec3 sphereRandom = sampleSphere(vec2(rand01(), rand01()));
	const vec3 gi_direction = randomizedOnHemisphere(sphereRandom, geometry_normal);

	payload.hit_t = vec4(0.);
	payload.base_color_a = vec4(0.);
	payload.normals_gs = vec4(0.);
	payload.material_rmxx = vec4(0.);
	payload.emissive = vec4(0.);

	traceRayEXT(tlas, flags, GEOMETRY_BIT_OPAQUE, // | GEOMETRY_BIT_REFRACTIVE,
		sbt_offset, sbt_stride, SHADER_OFFSET_MISS_REGULAR,
		bounce_origin, 0., normalize(gi_direction), L,
		PAYLOAD_LOCATION_PRIMARY);

	imageStore(out_image_base_color_a, ivec2(gl_LaunchIDEXT.xy), out_base_color_a);
	imageStore(out_image_position_t, ivec2(gl_LaunchIDEXT.xy), out_position_t);
	imageStore(out_image_normals_gs, ivec2(gl_LaunchIDEXT.xy), out_normals_gs);
	imageStore(out_image_material_rmxx, ivec2(gl_LaunchIDEXT.xy), out_material_rmxx);
	imageStore(out_image_emissive, ivec2(gl_LaunchIDEXT.xy), out_emissive);
	imageStore(out_image_search_info_ktuv, ivec2(gl_LaunchIDEXT.xy), out_search_info_ktuv);

	imageStore(out_image_refl_base_color_a, ivec2(gl_LaunchIDEXT.xy), out_refl_base_color_a);
	imageStore(out_image_refl_position_t, ivec2(gl_LaunchIDEXT.xy), out_refl_position_t);
	imageStore(out_image_refl_normals_gs, ivec2(gl_LaunchIDEXT.xy), out_refl_normals_gs);
	imageStore(out_image_refl_material_rmxx, ivec2(gl_LaunchIDEXT.xy), out_refl_material_rmxx);
	imageStore(out_image_refl_emissive, ivec2(gl_LaunchIDEXT.xy), out_refl_emissive);

	imageStore(out_image_gi_base_color_a, ivec2(gl_LaunchIDEXT.xy), payload.base_color_a);
	imageStore(out_image_gi_position_t, ivec2(gl_LaunchIDEXT.xy), payload.hit_t);
	imageStore(out_image_gi_normals_gs, ivec2(gl_LaunchIDEXT.xy), payload.normals_gs);
	imageStore(out_image_gi_emissive, ivec2(gl_LaunchIDEXT.xy), payload.emissive);
}
