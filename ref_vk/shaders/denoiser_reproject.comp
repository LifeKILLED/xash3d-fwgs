#version 460

#include "noise.glsl"
#include "utils.glsl"
#include "denoiser_tools.glsl"

#define PARALLAX_FACTOR_POW 2.

#define NORMALS_DIFFERENCE_LOW 0.93
#define NORMALS_DIFFERENCE_HIGH 0.97

#define DIFFUSE_BLEND_LIMIT .95
#define SPECULAR_BLEND_LIMIT .9
#define GI_BLEND_LIMIT .95

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

//layout(set = 0, binding = 0, rgba16f) uniform image2D out_diffuse_reproject;
//layout(set = 0, binding = 1, rgba16f) uniform image2D out_specular_reproject;
//layout(set = 0, binding = 2, rgba16f) uniform image2D out_gi_sh1_reproject;
//layout(set = 0, binding = 3, rgba16f) uniform image2D out_gi_sh2_reproject;
//
layout(set = 0, binding = 0, rgba16f) uniform image2D out_diffuse_accum;
layout(set = 0, binding = 1, rgba16f) uniform image2D out_specular_accum;
layout(set = 0, binding = 2, rgba16f) uniform image2D out_gi_sh1_accum;
layout(set = 0, binding = 3, rgba16f) uniform image2D out_gi_sh2_accum;

layout(set = 0, binding = 4, rgba16f)  uniform readonly image2D src_last_diffuse;
layout(set = 0, binding = 5, rgba16f)  uniform readonly image2D src_last_specular;
layout(set = 0, binding = 6, rgba16f) uniform readonly image2D src_last_gi_sh1;
layout(set = 0, binding = 7, rgba16f) uniform readonly image2D src_last_gi_sh2;

layout(set = 0, binding = 8, rgba32f) uniform readonly image2D src_position_t;
layout(set = 0, binding = 9, rgba16f) uniform readonly image2D src_normals_gs;
layout(set = 0, binding = 10, rgba8)   uniform readonly image2D src_material_rmxx;
layout(set = 0, binding = 11, rgba16f) uniform readonly image2D src_motion_offsets_uvs;

layout(set = 0, binding = 12, rgba16f) uniform readonly image2D src_refl_normals_gs;
layout(set = 0, binding = 13, rgba32f) uniform readonly image2D src_refl_position_t;
layout(set = 0, binding = 14, rgba32f) uniform readonly image2D src_last_position_t;

layout(set = 0, binding = 15, rgba32f) uniform readonly image2D src_search_info_ktuv;
layout(set = 0, binding = 16, rgba32f) uniform readonly image2D src_last_search_info_ktuv;

void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_normals_gs, uv);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}

void readReflNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	//const vec4 n = imageLoad(src_refl_normals_gs, uv);
	const vec4 n = vec4(1.);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}


void readLastNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
//	//const vec4 n = imageLoad(src_last_normals_gs, uv);
	const vec4 n = vec4(1.);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}

void main() {
	ivec2 res = ivec2(imageSize(out_diffuse_accum));
	ivec2 pix = ivec2(gl_GlobalInvocationID);
	const vec2 uv = (pix.xy + .5) / res.xy * 2. - 1.;

	if (any(greaterThanEqual(pix, res))) {
		return;
	}
	
#define THERE_IS(uv_offset) (uv_offset.x > -99.)


	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);

	const float depth = imageLoad(src_position_t, pix).w;
	const float reflLength = length(imageLoad(src_refl_position_t, pix).xyz - imageLoad(src_position_t, pix).xyz);

	const vec4 motion_offsets_uvs = imageLoad(src_motion_offsets_uvs, pix);
	vec2 forward_offset = motion_offsets_uvs.xy;
	vec2 parallax_offset = motion_offsets_uvs.zw;
	const float depthTreshold = 30.;

#ifdef ADD_SAMPLES_FOR_NOT_REPROJECTED
	const float min_samples = 1 + ADD_SAMPLES_FOR_NOT_REPROJECTED;
#else
	const float min_samples = 1.;
#endif

	const vec4 diffuse_src = vec4(imageLoad(out_diffuse_accum, pix).rgb, min_samples); 
	const vec4 specular_src = vec4(imageLoad(out_specular_accum, pix).rgb, min_samples); 
	const vec4 gi_sh1_src = imageLoad(out_gi_sh1_accum, pix); 
	const vec3 gi_sh2_src = vec3(imageLoad(out_gi_sh2_accum, pix).xy, min_samples); 



	float parallaxFactor = 0.;
	float last_parallaxFactor = 0.;
	float fallbackFactor = 0.;
	float samples_count = 0;
	float overlap_factor = 0.;

	vec4 last_diffuse = diffuse_src;
	vec4 last_specular = specular_src;
	vec4 last_gi_sh1 = gi_sh1_src;
	vec3 last_gi_sh2 = gi_sh2_src;

	vec4 diffuse_mixed = diffuse_src;
	vec4 specular_mixed = specular_src;
	vec4 gi_sh1_mixed = gi_sh1_src;
	vec3 gi_sh2_mixed = gi_sh2_src;
	vec4 last_forward_spec = specular_src;
	vec4 last_parallax_spec = specular_src;

//	forward_offset = uv;
//	parallax_offset = uv;

//	// remove bad reproject candidates from fake motion vectors data
//	if (THERE_IS(forward_offset)) {
//		// But we will searching for better equal texel in last frame
//		const vec4 search_info_ktuv = imageLoad(src_search_info_ktuv, pix);
//		const int KERNEL_SIZE = 3;
//		bool its_not_better_pix = false;
//
//		const ivec2 offset_pix = UVToPix(forward_offset, res);
//		const vec4 last_search_info_ktuv = imageLoad(src_last_search_info_ktuv, offset_pix);
//		const float uv_offset = length(search_info_ktuv.zw - last_search_info_ktuv.zw);
//
//		for (int x = -KERNEL_SIZE; x <= KERNEL_SIZE; ++x) {
//			for (int y = -KERNEL_SIZE; y <= KERNEL_SIZE; ++y) {
//				const ivec2 p = pix + ivec2(x, y);
//
//				if (any(greaterThanEqual(p, res)) ||
//					any(lessThan(p, ivec2(0))) ||
//					any(equal(p, pix)))
//						continue;
//
//				const vec2 current_offset_uv = imageLoad(src_motion_offsets_uvs, p).xy;
//				if (current_offset_uv.x > -99.) {
//					const ivec2 current_pix = UVToPix(current_offset_uv, res);
//					const vec4 current_info_ktuv = imageLoad(src_last_search_info_ktuv, current_pix);
//
//					if (current_pix.x == offset_pix.x && current_pix.y == offset_pix.y &&
//						/*search_info_ktuv.x == current_info_ktuv.x &&*/ search_info_ktuv.y == current_info_ktuv.y) {
//
//						const float current_uv_offset = length(search_info_ktuv.zw - current_info_ktuv.zw);
//						if (current_uv_offset < uv_offset) {
//							forward_offset = vec2(-100., 0.);
//							parallax_offset = vec2(-100., 0.);
//						}
//					}
//				}
//			}
//		}
//	}

	// Get color from simple motion vector
	if (THERE_IS(forward_offset)) {
		const ivec2 last_pix = UVToPix(forward_offset, res);
		//const ivec2 last_pix = pix; // DEBUG!!!!!!

		last_diffuse = imageLoad(src_last_diffuse, last_pix);
		last_diffuse.w += 1.; // increase sample count

		last_forward_spec = imageLoad(src_last_specular, last_pix);
		last_forward_spec.w += 1.; // increase sample count

		last_gi_sh1 = imageLoad(src_last_gi_sh1, last_pix);
		last_gi_sh2 = imageLoad(src_last_gi_sh2, last_pix).xyz;
		last_gi_sh2.z += 1.; // increase sample count

		//const float last_depth = imageLoad(src_last_position_t, last_pix).w;
		//overlap_factor = smoothstep(0., depthTreshold, depth - last_depth);
		overlap_factor = 0.; // we don't need to check depth here

		diffuse_mixed = mix(last_diffuse, diffuse_src, overlap_factor);
		specular_mixed = mix(last_forward_spec, specular_src, overlap_factor);
		gi_sh1_mixed = mix(last_gi_sh1, gi_sh1_src, overlap_factor);
		gi_sh2_mixed = mix(last_gi_sh2, gi_sh2_src, overlap_factor);
	}

	// Old, delete this 
	// Parallax reprojecting for specular reflection
//	if (THERE_IS(parallax_offset) && THERE_IS(forward_offset)) {
//
//		const ivec2 parallax_pix = UVToPix(parallax_offset, res);
//		last_parallax_spec = imageLoad(src_last_specular, parallax_pix);
//		last_parallax_spec.w += 1.; // increase sample count
//
//		vec3 parallaxGeometry_normal, parallaxShading_normal;
//		readLastNormals(parallax_pix, parallaxGeometry_normal, parallaxShading_normal);
//
//		// Is parallax reprojecting in current texel?
//		const float normalsDifference = dot(normalize(geometry_normal), normalize(shading_normal));
//		parallaxFactor = pow(smoothstep(NORMALS_DIFFERENCE_LOW, NORMALS_DIFFERENCE_HIGH, normalsDifference), PARALLAX_FACTOR_POW);
//
//		// Is parallax reprojecting on previous frame texel?
//		const float last_normalsDifference = dot(normalize(parallaxGeometry_normal), normalize(parallaxShading_normal));
//		last_parallaxFactor = pow(smoothstep(NORMALS_DIFFERENCE_LOW, NORMALS_DIFFERENCE_HIGH, last_normalsDifference), PARALLAX_FACTOR_POW);
//
//		// Is parallax reprojecting canceled in texel from previous frame? 
//		fallbackFactor = parallaxFactor > 0. ? 1. - clamp(0., 1., ((1. - last_parallaxFactor) - (1. - parallaxFactor))) * 2. : 0.;
//
//		//const float last_depth = imageLoad(src_last_position_t, parallax_pix).w;
//		//overlap_factor = 1. - smoothstep(0., depthTreshold, depth - last_depth);
//		overlap_factor = 1.; // we don't need to check depth here
//
//		last_parallax_spec = mix(specular_src, last_parallax_spec, parallaxFactor * overlap_factor);
//	}

  // New
	if (THERE_IS(parallax_offset) && THERE_IS(forward_offset)) {

		const ivec2 parallax_pix = UVToPix(parallax_offset, res);
		specular_mixed = imageLoad(src_last_specular, parallax_pix);
		specular_mixed.w += 1.; // increase sample count

		//vec3 parallaxGeometry_normal, parallaxShading_normal;
		//readLastNormals(parallax_pix, parallaxGeometry_normal, parallaxShading_normal);

		// Is parallax reprojecting in current texel?
		//const float normalsDifference = dot(normalize(geometry_normal), normalize(shading_normal));
		//parallaxFactor = pow(smoothstep(NORMALS_DIFFERENCE_LOW, NORMALS_DIFFERENCE_HIGH, normalsDifference), PARALLAX_FACTOR_POW);

		// Is parallax reprojecting on previous frame texel?
		//const float last_normalsDifference = dot(normalize(parallaxGeometry_normal), normalize(parallaxShading_normal));
		//last_parallaxFactor = pow(smoothstep(NORMALS_DIFFERENCE_LOW, NORMALS_DIFFERENCE_HIGH, last_normalsDifference), PARALLAX_FACTOR_POW);

		// Is parallax reprojecting canceled in texel from previous frame? 
		//fallbackFactor = parallaxFactor > 0. ? 1. - clamp(0., 1., ((1. - last_parallaxFactor) - (1. - parallaxFactor))) * 2. : 0.;

		//const float last_depth = imageLoad(src_last_position_t, parallax_pix).w;
		//overlap_factor = 1. - smoothstep(0., depthTreshold, depth - last_depth);
		//overlap_factor = 1.; // we don't need to check depth here

		//specular_mixed = mix(specular_src, specular_mixed, parallaxFactor * overlap_factor);
	}

//	specular_mixed = mix(specular_src, last_parallax_spec, fallbackFactor);
//	specular_mixed = mix(last_forward_spec, specular_mixed, parallaxFactor);

//	const float diffuse_difference = smoothstep(0.5, 1.5, length(diffuse_mixed.rgb - diffuse_src.rgb));
//	const float specular_difference = smoothstep(0.5, 1.5, length(specular_mixed.rgb - specular_src.rgb));

	const float diffuse_difference = 0.;
	const float specular_difference = 0.;
	const float gi_difference = 0.;
//
	//const float diffuse_frames_blend = 0.9;
	//const float specular_frames_blend = 0.9;
	//const float gi_frames_blend = 0.9;

	const float duffuse_samples_count = mix(diffuse_mixed.w, min_samples, diffuse_difference);
	const float specular_samples_count = mix(specular_mixed.w, min_samples, specular_difference);
	const float gi_samples_count = mix(gi_sh2_mixed.z, min_samples, gi_difference);

	const float diffuse_frames_blend = clamp(1. - 1. / duffuse_samples_count, .5, DIFFUSE_BLEND_LIMIT) /** diffuse_difference*/;
	const float specular_frames_blend = clamp(1. - 1. / specular_samples_count, .5, SPECULAR_BLEND_LIMIT) /** specular_difference*/;
	const float gi_frames_blend = clamp(1. - 1. / gi_samples_count, .5, GI_BLEND_LIMIT) /** gi_difference*/;

	diffuse_mixed = mix(diffuse_src, diffuse_mixed, diffuse_frames_blend);
	specular_mixed = mix(specular_src, specular_mixed, specular_frames_blend);
	gi_sh1_mixed = mix(gi_sh1_src, gi_sh1_mixed, gi_frames_blend);
	gi_sh2_mixed = mix(gi_sh2_src, gi_sh2_mixed, gi_frames_blend);





//	vec3 motion_reprojection_debug = vec3(0., 0., 1.);
//	if (motion_offsets_uvs.x > -99.) {
//		float debug_offset_scaler = 10.;
//		vec2 src_uv = (vec2(pix) + vec2(0.5)) / vec2(res) * 2. - vec2(1.);
//		vec2 current_offset_uv = (motion_offsets_uvs.xy - src_uv) * debug_offset_scaler * 0.5 + 0.5;
//		motion_reprojection_debug = vec3(current_offset_uv, 0.);
//	}


//	// debug non-reprojected texels
//	if (!(THERE_IS(forward_offset))) {
//		specular_mixed += vec4(.3, 0., 0., 0.);
//	}

	//imageStore(out_diffuse_accum, pix, vec4(motion_reprojection_debug, 0.0));


	imageStore(out_diffuse_accum, pix, diffuse_mixed);
	imageStore(out_specular_accum, pix, specular_mixed);
	imageStore(out_gi_sh1_accum, pix, gi_sh1_mixed);
	imageStore(out_gi_sh2_accum, pix, vec4(gi_sh2_mixed, reflLength));
}
