#version 460

#include "noise.glsl"
#include "utils.glsl"
#include "denoiser_tools.glsl"
#include "brdf.h"

#define PARALLAX_FACTOR_POW 2.

#define NORMALS_DIFFERENCE_LOW 0.93
#define NORMALS_DIFFERENCE_HIGH 0.97

#define DIFFUSE_BLEND_LIMIT .98
#define SPECULAR_BLEND_LIMIT .98
#define GI_BLEND_LIMIT .98

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

//layout(set = 0, binding = 0, rgba16f) uniform image2D out_diffuse_reproject;
//layout(set = 0, binding = 1, rgba16f) uniform image2D out_specular_reproject;
//layout(set = 0, binding = 2, rgba16f) uniform image2D out_gi_sh1_reproject;
//layout(set = 0, binding = 3, rgba16f) uniform image2D out_gi_sh2_reproject;
//
layout(set = 0, binding = 0, rgba16f) uniform image2D out_diffuse_accum;
layout(set = 0, binding = 1, rgba16f) uniform image2D out_specular_accum;
layout(set = 0, binding = 2, rgba16f) uniform image2D out_gi_sh1_accum;
layout(set = 0, binding = 3, rgba16f) uniform image2D out_gi_sh2_accum;
layout(set = 0, binding = 4, rgba16f) uniform image2D out_variance;

layout(set = 0, binding = 5, rgba16f)  uniform readonly image2D src_last_diffuse;
layout(set = 0, binding = 6, rgba16f)  uniform readonly image2D src_last_specular;
layout(set = 0, binding = 7, rgba16f) uniform readonly image2D src_last_gi_sh1;
layout(set = 0, binding = 8, rgba16f) uniform readonly image2D src_last_gi_sh2;

layout(set = 0, binding = 9, rgba32f) uniform readonly image2D src_position_t;
layout(set = 0, binding = 10, rgba16f) uniform readonly image2D src_normals_gs;
layout(set = 0, binding = 11, rgba8)   uniform readonly image2D src_material_rmxx;
layout(set = 0, binding = 12, rgba16f) uniform readonly image2D src_motion_offsets_uvs;

layout(set = 0, binding = 13, rgba16f) uniform readonly image2D src_refl_normals_gs;
layout(set = 0, binding = 14, rgba32f) uniform readonly image2D src_refl_position_t;
layout(set = 0, binding = 15, rgba32f) uniform readonly image2D src_last_position_t;

layout(set = 0, binding = 16, rgba32f) uniform readonly image2D src_search_info_ktuv;
layout(set = 0, binding = 17, rgba32f) uniform readonly image2D src_last_search_info_ktuv;

void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_normals_gs, uv);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}

void readReflNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	//const vec4 n = imageLoad(src_refl_normals_gs, uv);
	const vec4 n = vec4(1.);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}


void readLastNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
//	//const vec4 n = imageLoad(src_last_normals_gs, uv);
	const vec4 n = vec4(1.);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}

void main() {
	ivec2 res = ivec2(imageSize(out_diffuse_accum));
	ivec2 pix = ivec2(gl_GlobalInvocationID);
	const vec2 uv = (pix.xy + .5) / res.xy * 2. - 1.;

	if (any(greaterThanEqual(pix, res))) {
		return;
	}
	
#define THERE_IS(uv_offset) (uv_offset.x > -99.)


	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);

	const float depth = imageLoad(src_position_t, pix).w;
	const float reflLength = length(imageLoad(src_refl_position_t, pix).xyz - imageLoad(src_position_t, pix).xyz);

	const vec4 motion_offsets_uvs = imageLoad(src_motion_offsets_uvs, pix);
	vec2 forward_offset = motion_offsets_uvs.xy;
	vec2 parallax_offset = motion_offsets_uvs.zw;
	const float depthTreshold = 30.;

	const float metalness = imageLoad(src_material_rmxx, pix).y;

#ifdef ADD_SAMPLES_FOR_NOT_REPROJECTED
	const float min_samples = 1 + ADD_SAMPLES_FOR_NOT_REPROJECTED;
#else
	const float min_samples = 1.;
#endif

	const vec4 diffuse_src = vec4(imageLoad(out_diffuse_accum, pix).rgb, min_samples); 
	const vec4 specular_src = vec4(imageLoad(out_specular_accum, pix).rgb, min_samples); 
	const vec4 gi_sh1_src = imageLoad(out_gi_sh1_accum, pix); 
	const vec3 gi_sh2_src = vec3(imageLoad(out_gi_sh2_accum, pix).xy, min_samples); 


	float parallaxFactor = 0.;
	float last_parallaxFactor = 0.;
	float fallbackFactor = 0.;
	float samples_count = 0;
	float overlap_factor = 0.;
	vec4 variance = vec4(.2); // default is maximal variance

	vec4 last_diffuse = diffuse_src;
	vec4 last_specular = specular_src;
	vec4 last_gi_sh1 = gi_sh1_src;
	vec3 last_gi_sh2 = gi_sh2_src;

	vec4 diffuse_mixed = diffuse_src;
	vec4 specular_mixed = specular_src;
	vec4 gi_sh1_mixed = gi_sh1_src;
	vec3 gi_sh2_mixed = gi_sh2_src;
	vec4 last_forward_spec = specular_src;
	vec4 last_parallax_spec = specular_src;

	// Get color from simple motion vector for duffuse component
	if (THERE_IS(forward_offset)) {
		const ivec2 last_pix = UVToPix(forward_offset, res);

		last_diffuse = imageLoad(src_last_diffuse, last_pix);
		last_diffuse.w += 1.; // increase sample count

		last_forward_spec = imageLoad(src_last_specular, last_pix);
		last_forward_spec.w += 1.; // increase sample count

		last_gi_sh1 = imageLoad(src_last_gi_sh1, last_pix);
		last_gi_sh2 = imageLoad(src_last_gi_sh2, last_pix).xyz;
		last_gi_sh2.z += 1.; // increase sample count

		//const float last_depth = imageLoad(src_last_position_t, last_pix).w;
		overlap_factor = 0.; // we don't need to check depth here

		diffuse_mixed = mix(last_diffuse, diffuse_src, overlap_factor);
		gi_sh1_mixed = mix(last_gi_sh1, gi_sh1_src, overlap_factor);
		gi_sh2_mixed = mix(last_gi_sh2, gi_sh2_src, overlap_factor);
	}

	if (THERE_IS(parallax_offset)) {

		const ivec2 parallax_pix = UVToPix(parallax_offset, res);
		specular_mixed = imageLoad(src_last_specular, parallax_pix);
		specular_mixed.w += 1.; // increase sample count

		// for metal surfaces try to reproject gi from second bounce
		if (metalness > .5) {
			last_gi_sh1 = imageLoad(src_last_gi_sh1, parallax_pix);
			last_gi_sh2 = imageLoad(src_last_gi_sh2, parallax_pix).xyz;
			last_gi_sh2.z += 1.; // increase sample count
		}
	}

//	const float diffuse_difference = smoothstep(0.5, 1.5, length(diffuse_mixed.rgb - diffuse_src.rgb));
//	const float specular_difference = smoothstep(0.5, 1.5, length(specular_mixed.rgb - specular_src.rgb));

	const float diffuse_difference = 0.;
	const float specular_difference = 0.;
	const float gi_difference = 0.;

	const float duffuse_samples_count = mix(diffuse_mixed.w, min_samples, diffuse_difference);
	const float specular_samples_count = mix(specular_mixed.w, min_samples, specular_difference);
	const float gi_samples_count = mix(gi_sh2_mixed.z, min_samples, gi_difference);

	const float diffuse_frames_blend = clamp(1. - 1. / duffuse_samples_count, .5, DIFFUSE_BLEND_LIMIT) /** diffuse_difference*/;
	const float specular_frames_blend = clamp(1. - 1. / specular_samples_count, .5, SPECULAR_BLEND_LIMIT) /** specular_difference*/;
	const float gi_frames_blend = clamp(1. - 1. / gi_samples_count, .5, GI_BLEND_LIMIT) /** gi_difference*/;

	// calculate variance for specular if reprojecting is done
	if (THERE_IS(parallax_offset)) {
		vec2 moments = vec2(luminance(specular_src.rgb), 0.);
		moments.g    = moments.r * moments.r;

		vec2 prev_moments = vec2(luminance(specular_mixed.rgb), 0.);
		prev_moments.g    = prev_moments.r * prev_moments.r;

		moments = mix(prev_moments, moments, specular_frames_blend);
		variance = vec4(max(0.0f, moments.g - moments.r * moments.r)) * 2.;
	}

	diffuse_mixed = mix(diffuse_src, diffuse_mixed, diffuse_frames_blend);
	specular_mixed = mix(specular_src, specular_mixed, specular_frames_blend);
	gi_sh1_mixed = mix(gi_sh1_src, gi_sh1_mixed, gi_frames_blend);
	gi_sh2_mixed = mix(gi_sh2_src, gi_sh2_mixed, gi_frames_blend);

//	vec3 motion_reprojection_debug = vec3(0., 0., 1.);
//	if (motion_offsets_uvs.x > -99.) {
//		float debug_offset_scaler = 10.;
//		vec2 src_uv = (vec2(pix) + vec2(0.5)) / vec2(res) * 2. - vec2(1.);
//		vec2 current_offset_uv = (motion_offsets_uvs.xy - src_uv) * debug_offset_scaler * 0.5 + 0.5;
//		motion_reprojection_debug = vec3(current_offset_uv, 0.);
//	}
//	// debug non-reprojected texels
//	if (!(THERE_IS(forward_offset))) {
//		specular_mixed += vec4(.3, 0., 0., 0.);
//	}
//	imageStore(out_diffuse_accum, pix, vec4(motion_reprojection_debug, 0.0));

	imageStore(out_diffuse_accum, pix, diffuse_mixed);
	imageStore(out_specular_accum, pix, specular_mixed);
	imageStore(out_gi_sh1_accum, pix, gi_sh1_mixed);
	imageStore(out_gi_sh2_accum, pix, vec4(gi_sh2_mixed, reflLength));
	imageStore(out_variance, pix, variance);
}
