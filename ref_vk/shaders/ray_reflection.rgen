#version 460 core
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "ray_primary_common.glsl"
#include "utils.glsl"
#include "noise.glsl"
#include "color_spaces.glsl"
#include "denoiser_tools.glsl"
#include "brdf.h"

//#define EXTRA_SAMPLES_FOR_EMISSIVE 4

#define X(index, name, format) layout(set=0,binding=index,format) uniform readonly image2D src_image_##name;
RAY_REFLECTION_INPUTS(X)
#undef X

#define X(index, name, format) layout(set=0,binding=index,format) uniform image2D out_image_##name;
RAY_REFLECTION_OUTPUTS(X)
#undef X

layout(set = 0, binding = 1) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 2) uniform UBO { UniformBuffer ubo; };

// TODO: only for one texture, but... too many dependencies on adding more descriptors
layout(set = 0, binding = 6) uniform sampler2D textures[MAX_TEXTURES];

layout(location = PAYLOAD_LOCATION_PRIMARY) rayPayloadEXT RayPayloadPrimary payload;

void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_image_normals_gs, uv);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}

float ggxNormalDistribution( float NdotH, float roughness )
{
#ifndef M_PI
#define M_PI 3.1488
#endif
	float a2 = roughness * roughness;
	float d = ((NdotH * a2 - NdotH) * NdotH + 1);
	return a2 / (d * d * M_PI);
}


vec3 randomizedOnHemisphere(vec3 randomVec, vec3 normal) {
	float directionality = normalize(dot(normal, randomVec));
	return normalize(directionality * randomVec);
}

vec3 simpleRoughnessReflection(vec3 randomVec, vec3 viewDir, vec3 normal, float roughness) {
	vec3 clear = reflect(viewDir, normal);
	vec3 randomized = randomizedOnHemisphere(randomVec, normal);
	float distribution = ggxNormalDistribution(dot(normal, viewDir), roughness);
	return normalize(mix(clear, randomized, distribution * 0.5));
}


float maximalDotProduct(float roughness) {
	const vec3 normal = vec3(0., 0., 1.);
	const vec3 maxOffset = vec3(1., 0., 0.);
	const vec3 viewDir = vec3(0., 0., -1.);
	float distribution = ggxNormalDistribution(dot(normal, viewDir), roughness);
	vec3 normalOffset = normalize(mix(normal, viewDir, distribution * 0.5));
	return dot(normal, maxOffset);
}

vec3 sampleSphere(vec2 uv)
{
    float y = 2.0 * uv.x - 1;
    float theta = 2.0 * M_PI * uv.y;
    float r = sqrt(1.0 - y * y);
    return vec3(cos(theta) * r, y, sin(theta) * r);
}

// Microfacet bounce from this example https://www.shadertoy.com/view/Md3yWl

vec3 SphereRand( vec2 rand )
{
    rand += .5;
    float sina = rand.x*2. - 1.;
    float b = 6.283*rand.y;
    float cosa = sqrt(1.-sina*sina);
    return vec3(cosa*cos(b),sina,cosa*sin(b));
}

vec3 PowRand( vec3 rand, vec3 axis, float fpow )
{
	vec3 r = normalize(rand  - vec3(0.5));
	//vec3 r = sampleHemisphere(rand);
    //vec3 r = SphereRand(rand);
    float d = dot(r,axis);
    r -= d*axis;
    r = normalize(r);
    float h = d*.5+.5;
    r *= sqrt( 1. - pow( h, 2./(fpow+1.) ) );
    r += axis*sqrt(1.-dot(r,r));
    return r;
}



void main() {
	const vec2 uv = (gl_LaunchIDEXT.xy + .5) / gl_LaunchSizeEXT.xy * 2. - 1.;
	const ivec2 pix = ivec2(gl_LaunchIDEXT.xy);
	rand01_state = ubo.random_seed + gl_LaunchIDEXT.x * 1833 +  gl_LaunchIDEXT.y * 31337;

	// FIXME start on a near plane
	const vec3 view_origin    = (ubo.inv_view * vec4(0, 0, 0, 1)).xyz;
	const vec4 view_target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	const vec3 view_dir = normalize((ubo.inv_view * vec4(view_target.xyz, 0)).xyz);

	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);

	const vec3 origin = imageLoad(src_image_position_t, pix).xyz + geometry_normal;

	const vec4 material_data = imageLoad(src_image_material_rmxx, pix);

	MaterialProperties material;
	material.baseColor = vec3(1.);
	material.emissive = vec3(0.);
	material.metalness = material_data.g;
	material.roughness = min(0.6, material_data.r);
	//material.roughness = 0.3;

	// sample blue noise
	vec2 blue_noise_uv = vec2(pix % ivec2(BLUE_NOISE_TEX_RESOLUTION)) / vec2(BLUE_NOISE_TEX_RESOLUTION);
	vec4 blue_noise = texture(textures[nonuniformEXT(ubo.blue_noise_seed + BLUE_NOISE_TEX_ID)], blue_noise_uv);
	//const vec3 noise_vec = blue_noise.xyz;

	const float specPower = 1./ pow(material.roughness, 4.5);

	vec3 emissive = vec3(0.);

#ifdef EXTRA_SAMPLES_FOR_EMISSIVE
	for (int n = 0; n < EXTRA_SAMPLES_FOR_EMISSIVE; n++) {	
#endif

		const vec3 noise_vec = vec3(rand01(),rand01(),rand01());
		const vec3 microfacet = PowRand( noise_vec, shading_normal, specPower );
		vec3 direction = reflect(view_dir, microfacet);
		float coplanar = dot(geometry_normal, direction);
		if (coplanar < 0.) {
			direction += geometry_normal * (coplanar * -2.);
		}

		payload.hit_t = vec4(0.);
		payload.base_color_a = vec4(0.);
		payload.normals_gs = vec4(0.);
		payload.material_rmxx = vec4(0.);
		payload.emissive = vec4(0.);

		const uint flags = gl_RayFlagsCullFrontFacingTrianglesEXT;
		const uint sbt_offset = 0;
		const uint sbt_stride = 0;
		const float L = 10000.; // TODO Why 10k?
		traceRayEXT(tlas, flags, GEOMETRY_BIT_OPAQUE, // | GEOMETRY_BIT_REFRACTIVE,
			sbt_offset, sbt_stride, SHADER_OFFSET_MISS_REGULAR,
			origin, 0., normalize(direction), L,
			PAYLOAD_LOCATION_PRIMARY);

		emissive += max(vec3(0.), payload.emissive.rgb);

#ifdef EXTRA_SAMPLES_FOR_EMISSIVE
	}

	emissive /= EXTRA_SAMPLES_FOR_EMISSIVE;
#endif

	const vec3 refl_direction = reflect(view_dir, shading_normal);
	const float refl_length = length(origin - payload.hit_t.xyz);
	

	imageStore(out_image_refl_position_t, ivec2(gl_LaunchIDEXT.xy), vec4(payload.hit_t.xyz, material.roughness));
	imageStore(out_image_refl_base_color_a, ivec2(gl_LaunchIDEXT.xy), vec4(payload.base_color_a.rgb, payload.material_rmxx.y));
	imageStore(out_image_refl_normals_gs, ivec2(gl_LaunchIDEXT.xy), payload.normals_gs);
	imageStore(out_image_refl_material_rmxx, ivec2(gl_LaunchIDEXT.xy), payload.material_rmxx);
	imageStore(out_image_refl_emissive, ivec2(gl_LaunchIDEXT.xy), vec4(emissive, 0.));
	imageStore(out_image_refl_dir_length, ivec2(gl_LaunchIDEXT.xy), vec4(refl_direction, refl_length));
}
