#version 460 core
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "ray_primary_common.glsl"
#include "utils.glsl"
#include "noise.glsl"
#include "color_spaces.glsl"
#include "denoiser_tools.glsl"
#include "brdf.h"

#define X(index, name, format) layout(set=0,binding=index,format) uniform readonly image2D src_image_##name;
RAY_REFLECTION_INPUTS(X)
#undef X

#define X(index, name, format) layout(set=0,binding=index,format) uniform image2D out_image_##name;
RAY_REFLECTION_OUTPUTS(X)
#undef X

layout(set = 0, binding = 1) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 2) uniform UBO { UniformBuffer ubo; };

// TODO: only for one texture, but... too many dependencies on adding more descriptors
layout(set = 0, binding = 6) uniform sampler2D textures[MAX_TEXTURES];

layout(location = PAYLOAD_LOCATION_PRIMARY) rayPayloadEXT RayPayloadPrimary payload;

void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_image_normals_gs, uv);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}

float ggxNormalDistribution( float NdotH, float roughness )
{
#ifndef M_PI
#define M_PI 3.1488
#endif
	float a2 = roughness * roughness;
	float d = ((NdotH * a2 - NdotH) * NdotH + 1);
	return a2 / (d * d * M_PI);
}

//vec3 randomizedOnHemisphere(vec3 randomVec, vec3 normal) {
//	float directionality = normalize(dot(normal, randomVec));
//	return normalize(directionality * randomVec);
//}

vec3 randomizedOnHemisphere(vec3 randomVec, vec3 normal) {
	float directionality = normalize(dot(normal, randomVec));
	return normalize(directionality * randomVec);
}

vec3 simpleRoughnessReflection(vec3 randomVec, vec3 viewDir, vec3 normal, float roughness) {
	vec3 clear = reflect(viewDir, normal);
	vec3 randomized = randomizedOnHemisphere(randomVec, normal);
	float distribution = ggxNormalDistribution(dot(normal, viewDir), roughness);
	return normalize(mix(clear, randomized, distribution * 0.5));
}


float maximalDotProduct(float roughness) {
	const vec3 normal = vec3(0., 0., 1.);
	const vec3 maxOffset = vec3(1., 0., 0.);
	const vec3 viewDir = vec3(0., 0., -1.);
	float distribution = ggxNormalDistribution(dot(normal, viewDir), roughness);
	vec3 normalOffset = normalize(mix(normal, viewDir, distribution * 0.5));
	return dot(normal, maxOffset);
}

vec3 sampleSphere(vec2 uv)
{
    float y = 2.0 * uv.x - 1;
    float theta = 2.0 * M_PI * uv.y;
    float r = sqrt(1.0 - y * y);
    return vec3(cos(theta) * r, y, sin(theta) * r);
}

// get from this example https://www.shadertoy.com/view/Md3yWl

//uvec4 Hash( uint seed ) 
//{
//    // integer hash from Hugo Elias
//	seed = (seed << 13U) ^ seed;
//    seed = seed * (seed * seed * 15731U + 789221U) + 1376312589U;
//    return seed * uvec4(seed,seed*16807U,seed*48271U,seed*31713U);
//}
//
//vec4 Rand( uint seed )
//{
//    vec4 random = vec4(Hash(seed)&0x7fffffffU)/float(0x7fffffffU);
//    return random;
//}

vec3 SphereRand( vec2 rand )
{
    rand += .5;
    float sina = rand.x*2. - 1.;
    float b = 6.283*rand.y;
    float cosa = sqrt(1.-sina*sina);
    return vec3(cosa*cos(b),sina,cosa*sin(b));
}

vec3 PowRand( vec3 rand, vec3 axis, float fpow )
{
	vec3 r = normalize(rand  - vec3(0.5));
	//vec3 r = sampleHemisphere(rand);
    //vec3 r = SphereRand(rand);
    float d = dot(r,axis);
    r -= d*axis;
    r = normalize(r);
    float h = d*.5+.5;
    r *= sqrt( 1. - pow( h, 2./(fpow+1.) ) );
    r += axis*sqrt(1.-dot(r,r));
    return r;
}

// This is an entry point for evaluation of all other BRDFs based on selected configuration (for indirect light)
vec3 reflectBRDF(vec2 u, vec3 shadingNormal, vec3 geometryNormal, vec3 V, MaterialProperties material) {

	// for shading normal or for geometry normal?
//	float vCoplanarWithGeometry = dot(shadingNormal, V_src);
//	vec3 V = vCoplanarWithGeometry > 0. ? V_src : V_src - shadingNormal * vCoplanarWithGeometry;

	// Transform view direction into local space of our sampling routines
	// (local space is oriented so that its positive Z axis points along the shading normal)
	vec4 qRotationToZ = getRotationToZAxis(shadingNormal);
	vec3 Vlocal = rotatePoint(qRotationToZ, V);
	vec3 Nlocal = vec3(0.0f, 0.0f, 1.0f);



	vec3 rayDirectionLocal = vec3(0.);
	vec3 sampleWeight = vec3(0.);

	//vec3 Nlocal = sampleSpecularHalfVector(Vlocal, vec2(material.roughness * material.roughness), u);

	const BrdfData data = prepareBRDFData(Nlocal, vec3(0.0f, 0.0f, 1.0f) /* unused L vector */, Vlocal, material);
	//rayDirectionLocal = sampleGGXVNDFReflectionPdf(float alpha, float alphaSquared, float NdotH, float NdotV, float LdotH);
	rayDirectionLocal = sampleSpecular(Vlocal, data.alpha, data.alphaSquared, data.specularF0, u, sampleWeight);

	//rayDirectionLocal = reflect(-Vlocal, Nlocal);

	// Transform sampled direction Llocal back to V vector space
	vec3 rayDirection = normalize(rotatePoint(invertRotation(qRotationToZ), rayDirectionLocal));

	// Prevent tracing direction "under" the hemisphere (behind the triangle)
//	float rayCoplanarWithGeometry = dot(geometryNormal, rayDirection);
//	if (rayCoplanarWithGeometry < 0.) {
//		rayDirection -= geometryNormal * rayCoplanarWithGeometry;
//	}

	// Prevent tracing direction "under" the hemisphere (behind the triangle)
//	float rayCoplanarWithGeometry = dot(geometryNormal, rayDirection);
//	if (rayCoplanarWithGeometry < 0.) {
//		rayDirection -= geometryNormal * rayCoplanarWithGeometry * 1.1;
//	}

	return rayDirection;
}

void main() {
	const vec2 uv = (gl_LaunchIDEXT.xy + .5) / gl_LaunchSizeEXT.xy * 2. - 1.;
	const ivec2 pix = ivec2(gl_LaunchIDEXT.xy);
	rand01_state = ubo.random_seed + gl_LaunchIDEXT.x * 1833 +  gl_LaunchIDEXT.y * 31337;

	// FIXME start on a near plane
	const vec3 view_origin    = (ubo.inv_view * vec4(0, 0, 0, 1)).xyz;
	const vec4 view_target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	const vec3 view_dir = normalize((ubo.inv_view * vec4(view_target.xyz, 0)).xyz);

	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);

	const vec3 origin = imageLoad(src_image_position_t, pix).xyz + geometry_normal;

	const vec4 material_data = imageLoad(src_image_material_rmxx, pix);

	MaterialProperties material;
	material.baseColor = vec3(1.);
	material.emissive = vec3(0.);
	material.metalness = material_data.g;
	material.roughness = material_data.r;
	//material.roughness = 0.1;

	// sample blue noise
	vec2 blue_noise_uv = vec2(pix % ivec2(BLUE_NOISE_TEX_RESOLUTION)) / vec2(BLUE_NOISE_TEX_RESOLUTION);
	vec4 blue_noise = texture(textures[nonuniformEXT(ubo.blue_noise_seed + BLUE_NOISE_TEX_ID)], blue_noise_uv);
	//const vec3 u = normalize(blue_noise.rgb - vec3(.5));
	//const vec2 u = blue_noise.rg * 0.99 + blue_noise.ba * 0.01; // little dither
	//const vec2 u = blue_noise.rg;
	//const vec3 u = sampleSphere(blue_noise.rg * 0.7 + blue_noise.ba * 0.3);

	// true pseudo-random used only like dithering for two levels of fixed pattern-based directions
	//const vec3 randomVec = vec3(rand01(), rand01(), rand01()) * - vec3(0.5);
	//const vec3 u = controlledRandomDirection(pix, controlledRandomDirection(pix/4, randomVec * 8.).yzx * 4.);

	vec3 direction = reflectBRDF(blue_noise.xy, shading_normal, geometry_normal, view_dir, material);

	// randomize reflection direction with Blinn-Phong probability distribution





	//simpleRoughnessReflection

	const float specPower = 1./ pow(material.roughness, 4.5);
	const vec3 microfacet = PowRand( blue_noise.xyz, shading_normal, specPower );

//	vec3 direction = vec3(0.);
//
//	//const vec3 microfacet = shading_normal;
//
////	if (dot(microfacet, view_dir) < 0.) {
	direction = reflect(view_dir, microfacet);

	float coplanar = dot(geometry_normal, direction);
	if (coplanar < 0.) {
		direction += geometry_normal * (coplanar * -2.);
	}



	//const vec3 u = blue_noise.xyz * 2. - vec3(1.);
	//vec3 direction = simpleRoughnessReflection(blue_noise.xyz, view_dir, shading_normal, material.roughness);

//	vec3 direction = vec3(0.);
//	vec3 brdfWeight;
//	int brdfType = SPECULAR_TYPE;
//	if (evalIndirectCombinedBRDF(blue_noise.xy, shading_normal, geometry_normal, -view_dir, material, brdfType, direction, brdfWeight)) {
//
		payload.hit_t = vec4(0.);
		payload.base_color_a = vec4(0.);
		payload.normals_gs = vec4(0.);
		payload.material_rmxx = vec4(0.);
		payload.emissive = vec4(0.);

		const uint flags = gl_RayFlagsCullFrontFacingTrianglesEXT;
		const uint sbt_offset = 0;
		const uint sbt_stride = 0;
		const float L = 10000.; // TODO Why 10k?
		traceRayEXT(tlas, flags, GEOMETRY_BIT_OPAQUE, // | GEOMETRY_BIT_REFRACTIVE,
			sbt_offset, sbt_stride, SHADER_OFFSET_MISS_REGULAR,
			origin, 0., normalize(direction), L,
			PAYLOAD_LOCATION_PRIMARY);
	//}

	float depth = length(view_origin - origin);

	// brutforce calculation of median reflect direction and minimal dot product of cone
	vec3 medianDirection = reflect(view_dir, shading_normal);
	float minimalDot = 1.;
	//const vec3 microfacet_median = PowRand( vec3(0.5, 1., 0.3), vec3(0., 1., 0.), specPower );
	//float minimalDot = dot(vec3(0., 1., 0.), microfacet_median);

//	vec3 reflectionDirections[5];
//	for (int i = 0; i < 5; i++) {
//		const vec3 dir = reflectBRDF(uv_samples[i], shading_normal, geometry_normal, -view_dir, material);
//		reflectionDirections[i] = dir;
//		medianDirection += dir;
//	}
//	medianDirection = normalize(medianDirection);
//	for (int i = 0; i < 5; i++) {
//		const float currentDot = dot(medianDirection, reflectionDirections[i]);
//		if (currentDot < minimalDot) {
//			minimalDot = currentDot;
//		}
//	}

	imageStore(out_image_refl_position_t, ivec2(gl_LaunchIDEXT.xy), vec4(payload.hit_t.xyz, depth));
	imageStore(out_image_refl_base_color_a, ivec2(gl_LaunchIDEXT.xy), vec4(payload.base_color_a.rgb, payload.material_rmxx.y));
	//imageStore(out_image_refl_base_color_a, ivec2(gl_LaunchIDEXT.xy), blue_noise);
	//imageStore(out_image_refl_base_color_a, ivec2(gl_LaunchIDEXT.xy), (float(ubo.blue_noise_seed) / 32.) * vec4(1., 1., 0., 0.));
	imageStore(out_image_refl_normals_gs, ivec2(gl_LaunchIDEXT.xy), payload.normals_gs);
	imageStore(out_image_refl_material_rmxx, ivec2(gl_LaunchIDEXT.xy), payload.material_rmxx);
	imageStore(out_image_refl_emissive, ivec2(gl_LaunchIDEXT.xy), payload.emissive);
	imageStore(out_image_refl_dir_dot, ivec2(gl_LaunchIDEXT.xy), vec4(medianDirection, minimalDot));
}
