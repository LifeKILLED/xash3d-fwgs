#version 460

#include "noise.glsl"
#include "utils.glsl"
#include "lk_dnsr_spherical_harmonics.glsl"
#include "lk_dnsr_utils.glsl"
#include "color_spaces.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;


layout(set = 0, binding = 0, rgba16f) uniform image2D out_specular_accum;
layout(set = 0, binding = 1, rgba16f) uniform image2D out_diffuse_accum;
layout(set = 0, binding = 2, rgba16f) uniform image2D out_gi_sh1_accum;
layout(set = 0, binding = 3, rgba16f) uniform image2D out_gi_sh2_accum;

layout(set = 0, binding = 4, rgba8) uniform readonly image2D src_base_color;

layout(set = 0, binding = 5, rgba16f) uniform readonly image2D src_light_direct_poly_diffuse;
layout(set = 0, binding = 6, rgba16f) uniform readonly image2D src_light_direct_poly_specular;

layout(set = 0, binding = 7, rgba16f) uniform readonly image2D src_light_direct_point_diffuse;
layout(set = 0, binding = 8, rgba16f) uniform readonly image2D src_light_direct_point_specular;

layout(set = 0, binding = 9, rgba16f) uniform readonly image2D src_light_poly_reflection;
layout(set = 0, binding = 10, rgba16f) uniform readonly image2D src_light_point_reflection;
layout(set = 0, binding = 11, rgba16f) uniform readonly image2D src_light_poly_indirect;
layout(set = 0, binding = 12, rgba16f) uniform readonly image2D src_light_point_indirect;

layout(set = 0, binding = 13, rgba16f) uniform readonly image2D src_refl_emissive;
layout(set = 0, binding = 14, rgba16f) uniform readonly image2D src_gi_emissive;
layout(set = 0, binding = 15, rgba32f) uniform readonly image2D src_gi_position_t;
layout(set = 0, binding = 16, rgba32f) uniform readonly image2D src_position_t;
layout(set = 0, binding = 17, rgba32f) uniform readonly image2D src_refl_position_t;
layout(set = 0, binding = 18, rgba8) uniform readonly image2D src_material_rmxx;


void main() {
	ivec2 res = ivec2(imageSize(src_base_color));
	ivec2 pix = ivec2(gl_GlobalInvocationID);

	if (any(greaterThanEqual(pix, res))) {
		return;
	}

	const vec3 diffuse = imageLoad(src_light_direct_point_diffuse, pix).rgb +
						 imageLoad(src_light_direct_poly_diffuse, pix).rgb;

	const vec3 reflection_poly = imageLoad(src_light_poly_reflection, pix).rgb;

	vec3 reflection = vec3(0.);

	// Reuse lighting from screen if we can. -100 is SSR marker)
	if (reflection_poly.b < -99.) {
		ivec2 screen_pix = UVToPix(reflection_poly.rg, res);
		if (any(greaterThanEqual(screen_pix, ivec2(0))) && any(lessThan(screen_pix, res))) {
			vec4 refl_base_color_src = imageLoad(src_base_color, screen_pix);
			vec3 refl_base_color = SRGBtoLINEAR(refl_base_color_src.rgb);
			float refl_metalness = refl_base_color_src.a;
			vec3 refl_diffuse = imageLoad(src_light_direct_poly_diffuse, screen_pix).rgb +
								imageLoad(src_light_direct_point_diffuse, screen_pix).rgb;
			vec3 refl_specular = imageLoad(src_light_direct_poly_specular, screen_pix).rgb +
								imageLoad(src_light_direct_point_specular, screen_pix).rgb;

			reflection = PBRMix(refl_base_color.rgb, refl_diffuse, refl_specular, refl_metalness);
			reflection += imageLoad(src_refl_emissive, pix).rgb * 2.; // why?
			//reflection = vec3(100., 0., 0.); // TEST: visualize SSR texels
		}
	} else {
		reflection = reflection_poly + imageLoad(src_light_point_reflection, pix).rgb;
	}

//	// specular from lighting
	reflection +=	imageLoad(src_light_direct_point_specular, pix).rgb +
					imageLoad(src_light_direct_poly_specular, pix).rgb +
					imageLoad(src_refl_emissive, pix).rgb;


	// global illumination
	vec3 gi_poly = imageLoad(src_light_poly_indirect, pix).rgb;
	vec3 global_illumination =  imageLoad(src_light_point_indirect, pix).rgb +
								imageLoad(src_gi_emissive, pix).rgb;


	// Reuse lighting from screen if we can. -100 is SSGI marker)
	if (gi_poly.b < -99.) {
		ivec2 screen_pix = UVToPix(gi_poly.rg, res);
		if (any(greaterThanEqual(screen_pix, ivec2(0))) && any(lessThan(screen_pix, res))) {
			vec4 gi_base_color_src = imageLoad(src_base_color, screen_pix);
			vec3 gi_base_color = SRGBtoLINEAR(gi_base_color_src.rgb);
			float gi_metalness = gi_base_color_src.a;
			vec3 gi_diffuse = imageLoad(src_light_direct_poly_diffuse, screen_pix).rgb +
								imageLoad(src_light_direct_point_diffuse, screen_pix).rgb;
			vec3 gi_specular = imageLoad(src_light_direct_poly_specular, screen_pix).rgb +
								imageLoad(src_light_direct_point_specular, screen_pix).rgb;

			global_illumination = PBRMix(gi_base_color.rgb, gi_diffuse, gi_specular, gi_metalness);

			//global_illumination = vec3(100., 0., 0.); // TEST: visualize SSGI texels
		}
	} else {
		global_illumination += gi_poly;
	}

	vec4 gi_sh1 = vec4(0.);
	vec2 gi_sh2 = vec2(0.);

	const vec4 position = imageLoad(src_position_t, pix);

	// store indirectional light in spherical harmonics
	if (global_illumination.rgb != vec3(0., 0., 0.)) {
		const vec3 indirect_color = global_illumination.rgb * STORAGE_SCALE_LF;
		const vec3 gi_direction_src = imageLoad(src_gi_position_t, pix).xyz - position.xyz;
		const vec3 gi_direction = length(gi_direction_src) > 0. ? normalize(gi_direction_src) : vec3(1., 0., 0.);

		SH low_freq = irradiance_to_SH(indirect_color, gi_direction);
		gi_sh1 = low_freq.shY;
		gi_sh2 = low_freq.CoCg;
	}

	// store reflection ray length in last free component of gi_sh2
	const vec3 refl_position = imageLoad(src_refl_position_t, pix).xyz;
	const float reflection_ray_length = length(refl_position - position.xyz);

	imageStore(out_specular_accum, pix, vec4(reflection, 0.));
	imageStore(out_diffuse_accum, pix, vec4(diffuse, 0.));
	imageStore(out_gi_sh1_accum, pix, gi_sh1);
	imageStore(out_gi_sh2_accum, pix, vec4(gi_sh2, 0., reflection_ray_length));
}
