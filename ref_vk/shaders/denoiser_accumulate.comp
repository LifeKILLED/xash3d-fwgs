#version 460

#include "noise.glsl"
#include "utils.glsl"
#include "spherical_harmonics.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;


layout(set = 0, binding = 0, rgba16f) uniform image2D out_specular_accum;
layout(set = 0, binding = 1, rgba16f) uniform image2D out_diffuse_accum;
layout(set = 0, binding = 2, rgba16f) uniform image2D out_gi_accum_sh1;
layout(set = 0, binding = 3, rgba16f) uniform image2D out_gi_accum_sh2;

layout(set = 0, binding = 4, rgba8) uniform readonly image2D src_base_color;

layout(set = 0, binding = 5, rgba16f) uniform readonly image2D src_light_direct_poly_diffuse;
layout(set = 0, binding = 6, rgba16f) uniform readonly image2D src_light_direct_poly_specular;

layout(set = 0, binding = 7, rgba16f) uniform readonly image2D src_light_direct_point_diffuse;
layout(set = 0, binding = 8, rgba16f) uniform readonly image2D src_light_direct_point_specular;

layout(set = 0, binding = 9, rgba16f) uniform readonly image2D src_light_poly_reflection;
layout(set = 0, binding = 10, rgba16f) uniform readonly image2D src_light_point_reflection;
layout(set = 0, binding = 11, rgba16f) uniform readonly image2D src_light_poly_indirect;
layout(set = 0, binding = 12, rgba16f) uniform readonly image2D src_light_point_indirect;

layout(set = 0, binding = 13, rgba16f) uniform readonly image2D src_refl_emissive;
layout(set = 0, binding = 14, rgba16f) uniform readonly image2D src_gi_emissive;
layout(set = 0, binding = 15, rgba16f) uniform readonly image2D src_gi_direction;

// Blatantly copypasted from https://www.shadertoy.com/view/XsGfWV
vec3 aces_tonemap(vec3 color){
	mat3 m1 = mat3(
		0.59719, 0.07600, 0.02840,
		0.35458, 0.90834, 0.13383,
		0.04823, 0.01566, 0.83777
	);
	mat3 m2 = mat3(
		1.60475, -0.10208, -0.00327,
		-0.53108,  1.10813, -0.07276,
		-0.07367, -0.00605,  1.07602
	);
	vec3 v = m1 * color;
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));
	return clamp(m2 * (a / b), 0.0, 1.0);
}

vec3 reinhard(vec3 color){
	return color / (color + 1.0);
}

vec3 reinhard02(vec3 c, vec3 Cwhite2) {
	return c * (1. + c / Cwhite2) / (1. + c);
}

float normpdf2(in float x2, in float sigma) { return 0.39894*exp(-0.5*x2/(sigma*sigma))/sigma; }
float normpdf(in float x, in float sigma) { return normpdf2(x*x, sigma); }



ivec2 UVToPix(vec2 uv, ivec2 res) {
	vec2 screen_uv = uv * 0.5 + vec2(0.5);
	return ivec2(screen_uv.x * float(res.x), screen_uv.y * float(res.y));
}

void main() {
	ivec2 res = ivec2(imageSize(src_base_color));
	ivec2 pix = ivec2(gl_GlobalInvocationID);

	if (any(greaterThanEqual(pix, res))) {
		return;
	}

	// gray material diffuse component
	vec3 diffuse =	imageLoad(src_light_direct_poly_diffuse, pix).rgb +
					imageLoad(src_light_direct_point_diffuse, pix).rgb;

	// reflection and reuse info stored in texture with light data
	vec3 reflection_poly = imageLoad(src_light_poly_reflection, pix).rgb;
	vec3 reflection = vec3(0.);

	// Reuse lighting from screen if we can. -100 is SSR marker)
	if (reflection_poly.b < -99.) {
		ivec2 screen_pix = UVToPix(reflection_poly.rg, res);
		if (any(greaterThanEqual(screen_pix, ivec2(0))) && any(lessThan(screen_pix, res))) {
			vec3 refl_base_color = imageLoad(src_base_color, screen_pix).rgb;
			float refl_grayscale = (refl_base_color.r + refl_base_color.g + refl_base_color.b) * 0.33;
			float refl_specular_level = pow(refl_grayscale, 0.45); // fake specular map
			float refl_metalness = imageLoad(src_gi_direction, screen_pix).a;
			vec3 refl_diffuse = imageLoad(src_light_direct_poly_diffuse, screen_pix).rgb +
								imageLoad(src_light_direct_point_diffuse, screen_pix).rgb;
			vec3 refl_specular = imageLoad(src_light_direct_poly_specular, screen_pix).rgb +
								imageLoad(src_light_direct_point_specular, screen_pix).rgb;

			// metalness == 1
			vec3 refl_metal_colour = refl_specular * refl_base_color.rgb;

			// metalness == 0
			vec3 refl_dielectric_colour = (refl_diffuse) * refl_base_color.rgb +
									 (refl_specular) * refl_specular_level;

			// pbr
			reflection = mix(refl_dielectric_colour, refl_metal_colour, refl_metalness);

			//reflection = vec3(100., 0., 0.); // TEST: visualize SSR texels
		}
	} else {
		reflection = reflection_poly + imageLoad(src_light_point_reflection, pix).rgb;
	}

//	// specular from lighting
	reflection +=	imageLoad(src_light_direct_point_specular, pix).rgb +
					imageLoad(src_light_direct_poly_specular, pix).rgb;

	reflection += imageLoad(src_refl_emissive, pix).rgb;


	// global illumination
	vec3 global_illumination =	imageLoad(src_light_poly_indirect, pix).rgb +
								imageLoad(src_light_point_indirect, pix).rgb +
								imageLoad(src_gi_emissive, pix).rgb;


	vec4 gi_sh1 = vec4(0.);
	vec2 gi_sh2 = vec2(0.);


	// store indirectional light in spherical harmonics
	if (global_illumination.rgb != vec3(0., 0., 0.)) {
		vec3 indirect_color = global_illumination.rgb * STORAGE_SCALE_LF;
		vec3 gi_direction = imageLoad(src_gi_direction, pix).xyz;

		SH low_freq = irradiance_to_SH(indirect_color, gi_direction);
		gi_sh1 = low_freq.shY;
		gi_sh2 = low_freq.CoCg;
	}

	imageStore(out_specular_accum, pix, vec4(reflection, 0.));
	imageStore(out_diffuse_accum, pix, vec4(diffuse, 0.));
	imageStore(out_gi_accum_sh1, pix, gi_sh1);
	imageStore(out_gi_accum_sh2, pix, vec4(gi_sh2, 0., 0.));

}
