#version 460

#include "noise.glsl"
#include "utils.glsl"
#include "spherical_harmonics.glsl"
#include "denoiser_tools.glsl"
#include "color_spaces.glsl"

//#define LIGHTS_REJECTION_X4 1

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;


layout(set = 0, binding = 0, rgba16f) uniform image2D out_specular_accum;
layout(set = 0, binding = 1, rgba16f) uniform image2D out_diffuse_accum;
layout(set = 0, binding = 2, rgba16f) uniform image2D out_gi_sh1_accum;
layout(set = 0, binding = 3, rgba16f) uniform image2D out_gi_sh2_accum;

layout(set = 0, binding = 4, rgba8) uniform readonly image2D src_base_color;

layout(set = 0, binding = 5, rgba16f) uniform readonly image2D src_light_direct_poly_diffuse;
layout(set = 0, binding = 6, rgba16f) uniform readonly image2D src_light_direct_poly_specular;

layout(set = 0, binding = 7, rgba16f) uniform readonly image2D src_light_direct_point_diffuse;
layout(set = 0, binding = 8, rgba16f) uniform readonly image2D src_light_direct_point_specular;

layout(set = 0, binding = 9, rgba16f) uniform readonly image2D src_light_poly_reflection;
layout(set = 0, binding = 10, rgba16f) uniform readonly image2D src_light_point_reflection;
layout(set = 0, binding = 11, rgba16f) uniform readonly image2D src_light_poly_indirect;
layout(set = 0, binding = 12, rgba16f) uniform readonly image2D src_light_point_indirect;

layout(set = 0, binding = 13, rgba16f) uniform readonly image2D src_refl_emissive;
layout(set = 0, binding = 14, rgba16f) uniform readonly image2D src_gi_emissive;
layout(set = 0, binding = 15, rgba32f) uniform readonly image2D src_gi_position_t;
layout(set = 0, binding = 16, rgba32f) uniform readonly image2D src_position_t;

// Blatantly copypasted from https://www.shadertoy.com/view/XsGfWV
vec3 aces_tonemap(vec3 color){
	mat3 m1 = mat3(
		0.59719, 0.07600, 0.02840,
		0.35458, 0.90834, 0.13383,
		0.04823, 0.01566, 0.83777
	);
	mat3 m2 = mat3(
		1.60475, -0.10208, -0.00327,
		-0.53108,  1.10813, -0.07276,
		-0.07367, -0.00605,  1.07602
	);
	vec3 v = m1 * color;
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));
	return clamp(m2 * (a / b), 0.0, 1.0);
}

vec3 reinhard(vec3 color){
	return color / (color + 1.0);
}

vec3 reinhard02(vec3 c, vec3 Cwhite2) {
	return c * (1. + c / Cwhite2) / (1. + c);
}



vec3 samplePolyDirect(ivec2 pix, ivec2 res) {
	if (any(lessThan(pix, ivec2(0))) && any(greaterThanEqual(pix, res))) return vec3(-100.);
	return imageLoad(src_light_direct_poly_diffuse, pix).rgb;
}

vec3 samplePolyDirectOpposite(ivec2 pix1, ivec2 pix2, ivec2 res) {
	const vec3 first = samplePolyDirect(pix1, res);
	const vec3 second = samplePolyDirect(pix2, res);
	if (first.x < 0.99) return second;
	else if (first.x < 0.99) return first;
	return (first + second) / 2.;
}


vec3 samplePolyReflect(ivec2 pix, ivec2 res) {
	if (any(lessThan(pix, ivec2(0))) && any(greaterThanEqual(pix, res))) return vec3(-100.);
	return imageLoad(src_light_poly_reflection, pix).rgb;
}

vec3 samplePolyReflectOpposite(ivec2 pix1, ivec2 pix2, ivec2 res) {
	const vec3 first = samplePolyReflect(pix1, res);
	const vec3 second = samplePolyReflect(pix2, res);
	if (first.x < 0.99) return second;
	else if (first.x < 0.99) return first;
	return (first + second) / 2.;
}

void main() {
	ivec2 res = ivec2(imageSize(src_base_color));
	ivec2 pix = ivec2(gl_GlobalInvocationID);

	if (any(greaterThanEqual(pix, res))) {
		return;
	}

	

	//vec3 irradiance1 = 

#ifndef LIGHTS_REJECTION_X4 // full resolution

	const vec3 diffuse = imageLoad(src_light_direct_point_diffuse, pix).rgb +
						 imageLoad(src_light_direct_poly_diffuse, pix).rgb;
	const vec3 reflection_poly = imageLoad(src_light_poly_reflection, pix).rgb;

#else // LIGHTS_REJECTION_X4

	// gray material diffuse component
	const vec3 diffuse = imageLoad(src_light_direct_point_diffuse, pix).rgb +
						 imageLoad(src_light_direct_poly_diffuse, pix).rgb +
						 (samplePolyDirectOpposite(pix+ivec2(-1, -1), pix+ivec2(1, 1), res) +
						 samplePolyDirectOpposite(pix+ivec2(1, -1), pix+ivec2(-1, 1), res)) / 2. +
						 samplePolyDirectOpposite(pix+ivec2(-1, 0), pix+ivec2(1, 0), res) +
						 samplePolyDirectOpposite(pix+ivec2(0, -1), pix+ivec2(0, 1), res);
	

	//const vec3 diffuse = imageLoad(src_light_direct_poly_diffuse, pix).rgb +
	//					 imageLoad(src_light_direct_point_diffuse, pix).rgb;

	// reflection and reuse info stored in texture with light data
	const vec3 reflection_poly = imageLoad(src_light_poly_reflection, pix).rgb +
								(samplePolyReflectOpposite(pix+ivec2(-1, -1), pix+ivec2(1, 1), res) +
								 samplePolyReflectOpposite(pix+ivec2(1, -1), pix+ivec2(-1, 1), res)) / 2. +
								 samplePolyReflectOpposite(pix+ivec2(-1, 0), pix+ivec2(1, 0), res) +
								 samplePolyReflectOpposite(pix+ivec2(0, -1), pix+ivec2(0, 1), res);

#endif // LIGHTS_REJECTION_X4

	vec3 reflection = vec3(0.);

	// Reuse lighting from screen if we can. -100 is SSR marker)
	if (reflection_poly.b < -99.) {
		ivec2 screen_pix = UVToPix(reflection_poly.rg, res);
		if (any(greaterThanEqual(screen_pix, ivec2(0))) && any(lessThan(screen_pix, res))) {
			vec4 refl_base_color_src = imageLoad(src_base_color, screen_pix);
			vec3 refl_base_color = SRGBtoLINEAR(refl_base_color_src.rgb);
			float refl_metalness = refl_base_color_src.a;
			vec3 refl_diffuse = imageLoad(src_light_direct_poly_diffuse, screen_pix).rgb +
								imageLoad(src_light_direct_point_diffuse, screen_pix).rgb;
			vec3 refl_specular = imageLoad(src_light_direct_poly_specular, screen_pix).rgb +
								imageLoad(src_light_direct_point_specular, screen_pix).rgb;

			reflection = PBRMix(refl_base_color.rgb, refl_diffuse, refl_specular, refl_metalness);
			reflection += imageLoad(src_refl_emissive, pix).rgb * 2.; // why?
			//reflection = vec3(100., 0., 0.); // TEST: visualize SSR texels
		}
	} else {
		reflection = reflection_poly + imageLoad(src_light_point_reflection, pix).rgb;
	}

//	// specular from lighting
	reflection +=	imageLoad(src_light_direct_point_specular, pix).rgb +
					imageLoad(src_light_direct_poly_specular, pix).rgb +
					imageLoad(src_refl_emissive, pix).rgb;


	// global illumination
	vec3 gi_poly = imageLoad(src_light_poly_indirect, pix).rgb;
	vec3 global_illumination =  imageLoad(src_light_point_indirect, pix).rgb +
								imageLoad(src_gi_emissive, pix).rgb;


	// Reuse lighting from screen if we can. -100 is SSGI marker)
	if (gi_poly.b < -99.) {
		ivec2 screen_pix = UVToPix(gi_poly.rg, res);
		if (any(greaterThanEqual(screen_pix, ivec2(0))) && any(lessThan(screen_pix, res))) {
			vec4 gi_base_color_src = imageLoad(src_base_color, screen_pix);
			vec3 gi_base_color = SRGBtoLINEAR(gi_base_color_src.rgb);
			float gi_metalness = gi_base_color_src.a;
			vec3 gi_diffuse = imageLoad(src_light_direct_poly_diffuse, screen_pix).rgb +
								imageLoad(src_light_direct_point_diffuse, screen_pix).rgb;
			vec3 gi_specular = imageLoad(src_light_direct_poly_specular, screen_pix).rgb +
								imageLoad(src_light_direct_point_specular, screen_pix).rgb;

			global_illumination = PBRMix(gi_base_color.rgb, gi_diffuse, gi_specular, gi_metalness);

			//global_illumination = vec3(100., 0., 0.); // TEST: visualize SSGI texels
		}
	} else {
		global_illumination += gi_poly;
	}

	vec4 gi_sh1 = vec4(0.);
	vec2 gi_sh2 = vec2(0.);


	// store indirectional light in spherical harmonics
	if (global_illumination.rgb != vec3(0., 0., 0.)) {
		const vec3 indirect_color = global_illumination.rgb * STORAGE_SCALE_LF;
		const vec3 gi_direction_src = imageLoad(src_gi_position_t, pix).xyz - imageLoad(src_position_t, pix).xyz;
		const vec3 gi_direction = length(gi_direction_src) > 0. ? normalize(gi_direction_src) : vec3(1., 0., 0.);

		SH low_freq = irradiance_to_SH(indirect_color, gi_direction);
		gi_sh1 = low_freq.shY;
		gi_sh2 = low_freq.CoCg;
	}

	imageStore(out_specular_accum, pix, vec4(reflection, 0.));
	imageStore(out_diffuse_accum, pix, vec4(diffuse, 0.));
	imageStore(out_gi_sh1_accum, pix, gi_sh1);
	imageStore(out_gi_sh2_accum, pix, vec4(gi_sh2, 0., 0.));
}
