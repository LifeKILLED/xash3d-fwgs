#version 460

#define KERNEL_SIZE 8
#define KERNEL_OFFSET 2

#define KERNEL_FALLBACK 4

#include "noise.glsl"
#include "brdf.h"
#include "utils.glsl"
#include "denoiser_tools.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D out_specular_denoised;

layout(set = 0, binding = 1, rgba16f) uniform readonly image2D src_specular_accum;
layout(set = 0, binding = 2, rgba32f) uniform readonly image2D src_position_t;
layout(set = 0, binding = 3, rgba16f) uniform readonly image2D src_refl_position_t;
layout(set = 0, binding = 4, rgba16f) uniform readonly image2D src_normals_gs;
layout(set = 0, binding = 5, rgba8) uniform readonly image2D src_material_rmxx;
layout(set = 0, binding = 6, rgba16f) uniform readonly image2D src_refl_normals_gs;
layout(set = 0, binding = 7, rgba16f) uniform readonly image2D src_refl_dir_dot;
layout(set = 0, binding = 8, rgba16f) uniform readonly image2D src_last_reflection;
layout(set = 0, binding = 9, rgba16f) uniform readonly image2D src_last_position_t;
layout(set = 0, binding = 10, rgba16f) uniform readonly image2D src_last_normals_gs;
layout(set = 0, binding = 11, rgba16f) uniform readonly image2D src_motion_offsets_uvs;

//
//vec3 reinhard(vec3 color){
//	return color / (color + 1.0);
//}
//
//vec3 reinhard02(vec3 c, vec3 Cwhite2) {
//	return c * (1. + c / Cwhite2) / (1. + c);
//}
//
//
//

//ivec2 UVToPix(vec2 uv, ivec2 res) {
//	vec2 screen_uv = uv * 0.5 + vec2(0.5);
//	return ivec2(screen_uv.x * float(res.x), screen_uv.y * float(res.y));
//}
void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_normals_gs, uv);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}

void readReflNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_refl_normals_gs, uv);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}


void readLastNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(src_last_normals_gs, uv);
	geometry_normal = normalize(normalDecode(n.xy));
	shading_normal = normalize(normalDecode(n.zw));
}



void main() {
	ivec2 res = ivec2(imageSize(src_specular_accum));
	ivec2 pix = ivec2(gl_GlobalInvocationID);

	if (any(greaterThanEqual(pix, res))) {
		return;
	}

	// clean reflections filter get only texels from roughness cone
	// fallback reflections get little more than roughness cone
	// on corners we just use fallback filter if samples is small count
	// it's looks like we add little roughness and fixed black dots

	vec3 specular = vec3(0.);
	//vec3 specular = imageLoad(src_specular_accum, pix).rgb;



	float roughness = imageLoad(src_material_rmxx, pix).r;
		
	vec3 shading_normal = vec3(0.), geometry_normal = vec3(0.);
	vec3 refl_shading_normal = vec3(0.), refl_geometry_normal = vec3(0.);
	vec3 current_shading_normal = vec3(0.), current_geometry_normal = vec3(0.);
	readNormals(pix, geometry_normal, shading_normal);

	const vec3 center_pos = imageLoad(src_position_t, pix).xyz;
	const vec3 refl_pos_src = imageLoad(src_refl_position_t, pix).xyz;
	const float rayLength_src = length(refl_pos_src - center_pos);
	const vec4 reflectionCone = imageLoad(src_refl_dir_dot, pix);
	const vec3 coneDirection = normalize(reflectionCone.xyz);
	const vec3 view_dir = reflect(-coneDirection, shading_normal);


	// Hand-made formula created by LifeKILLED on online graph visualizer
	const float lower_eval_value = 1. - mix(pow(1. - roughness, 5.), pow(1. - roughness, 2.), 0.4);
	const float max_blur_mixing = smoothstep(0.6, 0.7, roughness);

	//if (true) {
	//if (false) {
	if (roughness > 0.05) { // don't use for mirrors
	
		const float dotTreshold = 0.01;
		const float fallbackTreshold = 0.001;
		float weights_sum = 0.;

		for (int x = -KERNEL_SIZE; x <= KERNEL_SIZE; ++x) {
			for (int y = -KERNEL_SIZE; y <= KERNEL_SIZE; ++y) {
				const ivec2 p = pix + ivec2(x, y) * KERNEL_OFFSET;
				if (any(greaterThanEqual(p, res)) || any(lessThan(p, ivec2(0)))) {
					continue;
				}

				// is in roughness cone?
				const vec3 refl_pos = imageLoad(src_refl_position_t, p).xyz;
				const float currentDot = dot(coneDirection, normalize(refl_pos - center_pos));

				// Hand-made formula created by LifeKILLED on online graph visualizer
				const float eval = mix(smoothstep(lower_eval_value, 1., asin(currentDot) * 0.66), currentDot, max_blur_mixing);

				const float sigma = KERNEL_SIZE / 2.;
				const float weight = normpdf(x, sigma) * normpdf(y, sigma) * eval;

				if (currentDot > dotTreshold && weight > 0.) {
					const vec3 current_specular = imageLoad(src_specular_accum, p).rgb;

					specular += current_specular * weight;
					weights_sum += weight;
				}
			}
		}

		// extra blur by normals in noisy places
		if (weights_sum < fallbackTreshold) {
			const float normalsTreshold = 0.95;
			for (int x = -KERNEL_FALLBACK; x <= KERNEL_FALLBACK; ++x) {
				for (int y = -KERNEL_FALLBACK; y <= KERNEL_FALLBACK; ++y) {
					const ivec2 p = pix + ivec2(x, y);
					if (any(greaterThanEqual(p, res)) || any(lessThan(p, ivec2(0)))) {
						continue;
					}

					const float sigma = KERNEL_FALLBACK / 2.;
					const float weight = normpdf(x, sigma) * normpdf(y, sigma);

					vec3 current_geometry_normal, current_shading_normal;
					readNormals(p, current_geometry_normal, current_shading_normal);

					if (dot(geometry_normal, current_geometry_normal) > normalsTreshold) {
						const vec3 current_specular = imageLoad(src_specular_accum, p).rgb;
						specular += current_specular * weight;
						weights_sum += weight;
					}
				}
			}
		}

		if (weights_sum > 0.) {
			specular /= weights_sum;
		} else {
			specular = imageLoad(src_specular_accum, pix).rgb;
		}

	}
	else
	{
		specular = imageLoad(src_specular_accum, pix).rgb; // mirror, don't need to denoise
	}

	#define THERE_IS(uv_offset) (uv_offset.x > -99.)

	// Temporal reprojection
	const float depth = imageLoad(src_position_t, pix).w;
	const vec4 motion_offsets_uvs = imageLoad(src_motion_offsets_uvs, pix);
	const vec2 forward_offset = motion_offsets_uvs.xy;
	const vec2 parallax_offset = motion_offsets_uvs.zw;
	const float depthTreshold = 30.;

	vec3 last_forward_spec = specular;
	vec3 last_parallax_spec = specular;
	float parallaxFactor = 0.;

	if (THERE_IS(forward_offset)) {
		const ivec2 last_pix = UVToPix(forward_offset, res);
		last_forward_spec = imageLoad(src_last_reflection, last_pix).xyz;

		const float last_depth = imageLoad(src_last_position_t, last_pix).w;
		const float overlap_factor = smoothstep(0., depthTreshold, depth - last_depth);
		last_forward_spec = mix(last_forward_spec, specular, overlap_factor);
	}

	if (THERE_IS(parallax_offset.x)) {
		const ivec2 last_pix = UVToPix(parallax_offset, res);
		last_parallax_spec = imageLoad(src_last_reflection, last_pix).xyz;

		const float normalsDifferenceLower = 0.95;
		const float normalsDifferenceHigher = 1.;
		const float normalsDifference = dot(normalize(geometry_normal), normalize(shading_normal));

		vec3 parallaxGeometry_normal, parallaxShading_normal;
		readLastNormals(last_pix, parallaxGeometry_normal, parallaxShading_normal);

		const float lastNormalsDifference = dot(normalize(parallaxGeometry_normal), normalize(parallaxShading_normal));

		const float normalsLastDifference = dot(normalize(geometry_normal), normalize(shading_normal));
		const float parallaxFactorLast = smoothstep(normalsDifferenceLower, normalsDifferenceHigher, lastNormalsDifference);
		parallaxFactor = smoothstep(normalsDifferenceLower, normalsDifferenceHigher, normalsDifference) * parallaxFactorLast;

		const float last_depth = imageLoad(src_last_position_t, last_pix).w;
		const float overlap_factor = smoothstep(0., depthTreshold, depth - last_depth);
		last_parallax_spec = mix(last_parallax_spec, specular, overlap_factor);
	}

	vec3 last_specular = mix(last_forward_spec, last_parallax_spec, parallaxFactor);

	float specular_difference = 1.;
	//float specular_difference = 1. - smoothstep(0.5, 1.0, length(last_specular - specular));




//    // Simple get sample by last position
//	float specular_difference = 0.;
//	vec3 last_specular = vec3(0.);
//	if (THERE_IS(forward_offset)) {
//		const ivec2 last_pix = UVToPix(forward_offset, res);
//		last_specular = imageLoad(src_last_reflection, last_pix).xyz;
//		specular_difference = 1.;
//	}

	specular = clamp(mix(specular, last_specular, specular_difference * 0.8), 0., 5.0);

	//specular = vec3(motion_offset.xy, 0.); // TEST: motion offsets visualize

	imageStore(out_specular_denoised, pix, vec4(specular, 0.));

}
